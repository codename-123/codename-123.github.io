---
title: "Yummy (Hard)"
date: 2025-10-21
layout: single
excerpt: "Yummy는 Caddy 웹서버가 포트 80에서 동작하는 레스토랑 웹 앱으로 시작하는 Hard 난이도 박스이다. 공격자는 HTTP Location 헤더에서 임의 파일 읽기 취약점을 발견하는데, 이는 기본 Caddy 설정에서 제대로 처리/정규화되지 않는다. 웹 애플리케이션 소스 코드를 살펴보면 JWT에 RSA 키페어를 사용해 관리자 토큰을 위조(forge)하여 권한을 상승시킬 수 있다. 관리자 패널에는 SQL 인젝션이 있어 임의 파일 쓰기가 가능하고, 공격자는 이를 이용해 주기적으로 실행되는 파일(크론잡)을 덮어쓴다. 부적절한 디렉터리 권한 설정으로 공격자는 www-data로 횡적 이동(lateral movement)할 수 있고, 결국 dev 사용자로 권한을 얻는다. dev 사용자는 루트로 실행 가능한 rsync 바이너리를 실행할 수 있어 이를 통해 최종적으로 루트 권한을 획득한다."
author_profile: true
toc: true
toc_label: "Yummy"
toc_icon: "book"
toc_sticky: true
header:
  teaser: /assets/htb-linux/yummy/yummy.png
  teaser_home_page: true
categories: [hackthebox linux]
tags: [htb, yummy, web, jwt, sqli, priv-esc]
---

![Yummy](/assets/htb-linux/yummy/yummy.png)

Yummy는 `Caddy` 웹서버가 포트 80에서 동작하는 레스토랑 웹 앱으로 시작하는 Hard 난이도 박스이다. 

공격자는 `HTTP Location` 헤더에서 **임의 파일 읽기 취약점**을 발견하는데, 이는 기본 `Caddy` 설정에서 제대로 처리/정규화되지 않는다. 

웹 애플리케이션 소스 코드를 살펴보면 `JWT`에 **RSA 키페어**를 사용해 **토큰을 위조(forge)**하여 권한을 상승시킬 수 있다. 관리자 패널에는 **SQL 인젝션**이 있어 **임의 파일 쓰기**가 가능하고, 공격자는 이를 이용해 주기적으로 실행되는 파일(`크론잡`)을 덮어쓴다. 

부적절한 디렉터리 권한 설정으로 공격자는 `www-data`로 **횡적 이동(lateral movement)**할 수 있고, 결국 `dev` 사용자로 권한을 얻는다. `dev` 사용자는 루트로 실행 가능한 `rsync` 바이너리를 실행할 수 있어 이를 통해 최종적으로 `루트` 권한을 획득한다.


# Enumeration

## Portscan

먼저 대상 Host(`10.10.11.36`)에 대해 기본 스크립트와 서비스 버전 탐지를 수행하였다.

```bash
$ nmap -sC -sV 10.10.11.36 | tee nmap
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-21 15:27 EDT
Nmap scan report for yummy.htb (10.10.11.36)
Host is up (0.22s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 9.6p1 Ubuntu 3ubuntu13.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 a2:ed:65:77:e9:c4:2f:13:49:19:b0:b8:09:eb:56:36 (ECDSA)
|_  256 bc:df:25:35:5c:97:24:f2:69:b4:ce:60:17:50:3c:f0 (ED25519)
80/tcp open  http    Caddy httpd
|_http-server-header: Caddy
|_http-title: Yummy
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 15.85 seconds
```

Nmap 스캔 결과, `SSH(22)`, `HTTP(80)`(Caddy httpd) 서비스가 열려 있고, 웹은 **yummy.htb** 도메인으로 접근해야 함을 확인했다.

## 도메인 이름 설정 (/etc/hosts)

웹 서비스 접근을 위해 `/etc/hosts` 파일에 **10.10.11.36 yummy.htb**를 추가하였다.

```bash
$ cat /etc/hosts | grep htb

10.10.11.36     yummy.htb
```

---

# Vulnerability Analysis

대상 웹 애플리케이션은 레스토랑 예약 기능을 제공하는 웹사이트로 보인다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/website.png)

회원가입을 통해 계정을 생성한 뒤 로그인하면 `Dashboard` 페이지로 접근이 가능하다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/dashboard.png)

위 사진에 보이는 `BOOK A TABLE`을 클릭하면 테이블을 예약할 수 있다. 예약을 하면 아래와 같이 Dashboard 페이지에 예약 내역이 표시된다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/reservation.png)

`Save iCalendar` 기능을 통해 예약 내역을 저장하면 `*.ics` 파일이 생성되는 것을 확인할 수 있다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/ics_file.png)

## LFI

Burp Suite를 실행한 후 `Save iCalendar` 기능으로 예약을 저장하면 `/export` 경로의 `*.ics` 파일과 함께 `/reminder/21` 경로가 생성된다. 이 `/reminder/21` 을 먼저 호출해 활성화해야만 `/export/*.ics` 경로가 동작한다

`/reminder/21` 경로는 `.ics` 파일과 관련된 저장소 엔드포인트로 추정된다.

우선 `/reminder/21` 을 활성화한 후,

![로그인 페이지 탐색](/assets/htb-linux/yummy/reminder.png)

`/export/*.ics` 경로를 요청하면 아래와 같이 `.ics` 파일의 정보를 읽을 수 있다.

![로그인 페이지 탐색](/assets/htb-linux/yummy/ics_file2.png)

위 매커니즘을 토대로 `/export` 경로에 `/etc/passwd` 를 넣어 요청한 결과 LFI 취약점이 존재함을 확인하였다

![로그인 페이지 탐색](/assets/htb-linux/yummy/lfi.png)

## Crontab

이후 `/etc/crontab` 을 확인한 결과, 다음 세 개의 스크립트가 cron에 등록되어 있었다.

- `/data/scripts/app_backup.sh`
- `/data/scripts/table_cleanup.sh`
- `/data/scripts/dbmonitor.sh`

![로그인 페이지 탐색](/assets/htb-linux/yummy/crontab.png)

## Per‑script analysis

`/data/scripts/app_backup.sh`는 `/var/www`로 이동한 뒤 `/opt/app`을 압축하여 `backupapp.zip`을 생성하는 백업 스크립트로 보인다.

```bash
#!/bin/bash

cd /var/www
/usr/bin/rm backupapp.zip
/usr/bin/zip -r backupapp.zip /opt/app
```

`/data/scripts/table_cleanup.sh` 는 15분 간격으로 MySQL 데이터베이스에 `/data/scripts/sqlappointments.sql` 를 적용하는 스크립트로, MySQL 접속 정보가 스크립트에 포함되어 있다.

```bash
#!/bin/sh

/usr/bin/mysql -h localhost -u chef yummy_db -p'3wDo7gSRZIwIHRxZ!' < /data/scripts/sqlappointments.sql
```

`/data/scripts/dbmonitor.sh` 는 MySQL 서비스 상태를 확인하고, 데이터베이스가 정상 동작하지 않거나 `/data/scripts/dbstatus.json` 에 내용이 존재할 경우 `/data/scripts/fixer-v*` 패턴에 매칭되는 파일 목록 중 버전 정렬 후 최신 파일을 선택하여 **/bin/bash "$latest_version"** 를 실행한다.

이 동작 방식으로 인해 `/data/scripts` 에 쓰기 권한이 있는 공격자가 `fixer-v*` 이름으로 악성 스크립트를 업로드할 경우, cron이 이를 실행하여 **임의 코드 실행(RCE)**으로 이어질 수 있다.

```bash
#!/bin/bash

timestamp=$(/usr/bin/date)
service=mysql
response=$(/usr/bin/systemctl is-active mysql)

if [ "$response" != 'active' ]; then
    /usr/bin/echo "{\"status\": \"The database is down\", \"time\": \"$timestamp\"}" > /data/scripts/dbstatus.json
    /usr/bin/echo "$service is down, restarting!!!" | /usr/bin/mail -s "$service is down!!!" root
    latest_version=$(/usr/bin/ls -1 /data/scripts/fixer-v* 2>/dev/null | /usr/bin/sort -V | /usr/bin/tail -n 1)
    /bin/bash "$latest_version"
else
    if [ -f /data/scripts/dbstatus.json ]; then
        if grep -q "database is down" /data/scripts/dbstatus.json 2>/dev/null; then
            /usr/bin/echo "The database was down at $timestamp. Sending notification."
            /usr/bin/echo "$service was down at $timestamp but came back up." | /usr/bin/mail -s "$service was down!" root
            /usr/bin/rm -f /data/scripts/dbstatus.json
        else
            /usr/bin/rm -f /data/scripts/dbstatus.json
            /usr/bin/echo "The automation failed in some way, attempting to fix it."
            latest_version=$(/usr/bin/ls -1 /data/scripts/fixer-v* 2>/dev/null | /usr/bin/sort -V | /usr/bin/tail -n 1)
            /bin/bash "$latest_version"
        fi
    else
        /usr/bin/echo "Response is OK."
    fi
fi

[ -f dbstatus.json ] && /usr/bin/rm -f dbstatus.json
```

## Source Leak

이제 LFI 취약점을 이용해 현재 실행 중인 `app.py` 파일의 소스코드를 확인하기 위해 `/proc/self/cwd` 경로를 사용하였다.

`/proc/self/cwd`는 현재 실행 중인 프로세스의 작업 디렉터리를 가리키는 심볼릭 링크이며, Flask 서버가 `app.py` 파일이 있는 디렉터리에서 직접 실행된 경우, 해당 경로는 `/var/www`가 아닌 `/proc/self/cwd`를 통해 접근할 수 있게 된다.

<details>  
    <summary>app.py 코드 보기 (클릭해서 열기/닫기)</summary>
    <div markdown="1">

```python
from flask import Flask, request, send_file, render_template, redirect, url_for, flash, jsonify, make_response
import tempfile
import os
import shutil
from datetime import datetime, timedelta, timezone
from urllib.parse import quote
from ics import Calendar, Event
from middleware.verification import verify_token
from config import signature
import pymysql.cursors
from pymysql.constants import CLIENT
import jwt
import secrets
import hashlib

app = Flask(__name__, static_url_path='/static')
temp_dir = ''
app.secret_key = secrets.token_hex(32)

db_config = {
    'host': '127.0.0.1',
    'user': 'chef',
    'password': '3wDo7gSRZIwIHRxZ!',
    'database': 'yummy_db',
    'cursorclass': pymysql.cursors.DictCursor,
    'client_flag': CLIENT.MULTI_STATEMENTS

}

access_token = ''

@app.route('/login', methods=['GET','POST'])
def login():
    global access_token
    if request.method == 'GET':
        return render_template('login.html', message=None)
    elif request.method == 'POST':
        email = request.json.get('email')
        password = request.json.get('password')
        password2 = hashlib.sha256(password.encode()).hexdigest()
        if not email or not password:
            return jsonify(message="email or password is missing"), 400

        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "SELECT * FROM users WHERE email=%s AND password=%s"
                cursor.execute(sql, (email, password2))
                user = cursor.fetchone()
                if user:
                    payload = {
                        'email': email,
                        'role': user['role_id'],
                        'iat': datetime.now(timezone.utc),
                        'exp': datetime.now(timezone.utc) + timedelta(seconds=3600),
                        'jwk':{'kty': 'RSA',"n":str(signature.n),"e":signature.e}
                    }
                    access_token = jwt.encode(payload, signature.key.export_key(), algorithm='RS256')

                    response = make_response(jsonify(access_token=access_token), 200)
                    response.set_cookie('X-AUTH-Token', access_token)
                    return response
                else:
                    return jsonify(message="Invalid email or password"), 401
        finally:
            connection.close()

@app.route('/logout', methods=['GET'])
def logout():
    response = make_response(redirect('/login'))
    response.set_cookie('X-AUTH-Token', '')
    return response

@app.route('/register', methods=['GET', 'POST'])
def register():
        if request.method == 'GET':
            return render_template('register.html', message=None)
        elif request.method == 'POST':
            role_id = 'customer_' + secrets.token_hex(4)
            email = request.json.get('email')
            password = hashlib.sha256(request.json.get('password').encode()).hexdigest()
            if not email or not password:
                return jsonify(error="email or password is missing"), 400
            connection = pymysql.connect(**db_config)
            try:
                with connection.cursor() as cursor:
                    sql = "SELECT * FROM users WHERE email=%s"
                    cursor.execute(sql, (email,))
                    existing_user = cursor.fetchone()
                    if existing_user:
                        return jsonify(error="Email already exists"), 400
                    else:
                        sql = "INSERT INTO users (email, password, role_id) VALUES (%s, %s, %s)"
                        cursor.execute(sql, (email, password, role_id))
                        connection.commit()
                        return jsonify(message="User registered successfully"), 201
            finally:
                connection.close()


@app.route('/', methods=['GET', 'POST'])
def index():
    return render_template('index.html')

@app.route('/book', methods=['GET', 'POST'])
def export():
    if request.method == 'POST':
        try:
            name = request.form['name']
            date = request.form['date']
            time = request.form['time']
            email = request.form['email']
            num_people = request.form['people']
            message = request.form['message']

            connection = pymysql.connect(**db_config)
            try:
                with connection.cursor() as cursor:
                    sql = "INSERT INTO appointments (appointment_name, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message, role_id) VALUES (%s, %s, %s, %s, %s, %s, %s)"
                    cursor.execute(sql, (name, email, date, time, num_people, message, 'customer'))
                    connection.commit()
                    flash('Your booking request was sent. You can manage your appointment further from your account. Thank you!', 'success')  
            except Exception as e:
                print(e)
            return redirect('/#book-a-table')
        except ValueError:
            flash('Error processing your request. Please try again.', 'error')
    return render_template('index.html')


def generate_ics_file(name, date, time, email, num_people, message):
    global temp_dir
    temp_dir = tempfile.mkdtemp()
    current_date_time = datetime.now()
    formatted_date_time = current_date_time.strftime("%Y%m%d_%H%M%S")

    cal = Calendar()
    event = Event()
    
    event.name = name
    event.begin = datetime.strptime(date, "%Y-%m-%d")
    event.description = f"Email: {email}\nNumber of People: {num_people}\nMessage: {message}"
    
    cal.events.add(event)

    temp_file_path = os.path.join(temp_dir, quote('Yummy_reservation_' + formatted_date_time + '.ics'))
    with open(temp_file_path, 'w') as fp:
        fp.write(cal.serialize())

    return os.path.basename(temp_file_path)

@app.route('/export/<path:filename>')
def export_file(filename):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))
    filepath = os.path.join(temp_dir, filename)
    if os.path.exists(filepath):
        content = send_file(filepath, as_attachment=True)
        shutil.rmtree(temp_dir)
        return content
    else:
        shutil.rmtree(temp_dir)
        return "File not found", 404

def validate_login():
    try:
        (email, current_role), status_code = verify_token()
        if email and status_code == 200 and current_role == "administrator":
            return current_role
        elif email and status_code == 200:
            return email
        else:
            raise Exception("Invalid token")
    except Exception as e:
        return None


@app.route('/dashboard', methods=['GET', 'POST'])
def dashboard():
        validation = validate_login()
        if validation is None:
            return redirect(url_for('login'))
        elif validation == "administrator":
            return redirect(url_for('admindashboard'))
 
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "SELECT appointment_id, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s"
                cursor.execute(sql, (validation,))
                connection.commit()
                appointments = cursor.fetchall()
                appointments_sorted = sorted(appointments, key=lambda x: x['appointment_id'])

        finally:
            connection.close()

        return render_template('dashboard.html', appointments=appointments_sorted)

@app.route('/delete/<appointID>')
def delete_file(appointID):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))
    elif validation == "administrator":
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "DELETE FROM appointments where appointment_id= %s;"
                cursor.execute(sql, (appointID,))
                connection.commit()

                sql = "SELECT * from appointments"
                cursor.execute(sql)
                connection.commit()
                appointments = cursor.fetchall()
        finally:
            connection.close()
            flash("Reservation deleted successfully","success")
            return redirect(url_for("admindashboard"))
    else:
        connection = pymysql.connect(**db_config)
        try:
            with connection.cursor() as cursor:
                sql = "DELETE FROM appointments WHERE appointment_id = %s AND appointment_email = %s;"
                cursor.execute(sql, (appointID, validation))
                connection.commit()

                sql = "SELECT appointment_id, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s"
                cursor.execute(sql, (validation,))
                connection.commit()
                appointments = cursor.fetchall()
        finally:
            connection.close()
            flash("Reservation deleted successfully","success")
            return redirect(url_for("dashboard"))
        flash("Something went wrong!","error")
        return redirect(url_for("dashboard"))

@app.route('/reminder/<appointID>')
def reminder_file(appointID):
    validation = validate_login()
    if validation is None:
        return redirect(url_for('login'))

    connection = pymysql.connect(**db_config)
    try:
        with connection.cursor() as cursor:
            sql = "SELECT appointment_id, appointment_name, appointment_email, appointment_date, appointment_time, appointment_people, appointment_message FROM appointments WHERE appointment_email = %s AND appointment_id = %s"
            result = cursor.execute(sql, (validation, appointID))
            if result != 0:
                connection.commit()
                appointments = cursor.fetchone()
                filename = generate_ics_file(appointments['appointment_name'], appointments['appointment_date'], appointments['appointment_time'], appointments['appointment_email'], appointments['appointment_people'], appointments['appointment_message'])
                connection.close()
                flash("Reservation downloaded successfully","success")
                return redirect(url_for('export_file', filename=filename))
            else:
                flash("Something went wrong!","error")
    except:
        flash("Something went wrong!","error")
        
    return redirect(url_for("dashboard"))

@app.route('/admindashboard', methods=['GET', 'POST'])
def admindashboard():
        validation = validate_login()
        if validation != "administrator":
            return redirect(url_for('login'))
 
        try:
            connection = pymysql.connect(**db_config)
            with connection.cursor() as cursor:
                sql = "SELECT * from appointments"
                cursor.execute(sql)
                connection.commit()
                appointments = cursor.fetchall()

                search_query = request.args.get('s', '')

                # added option to order the reservations
                order_query = request.args.get('o', '')

                sql = f"SELECT * FROM appointments WHERE appointment_email LIKE %s order by appointment_date {order_query}"
                cursor.execute(sql, ('%' + search_query + '%',))
                connection.commit()
                appointments = cursor.fetchall()
            connection.close()
            
            return render_template('admindashboard.html', appointments=appointments)
        except Exception as e:
            flash(str(e), 'error')
            return render_template('admindashboard.html', appointments=appointments)

if __name__ == '__main__':
    app.run(threaded=True, debug=False, host='0.0.0.0', port=3000)
```
</div>
</details>





